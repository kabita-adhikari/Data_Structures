<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Java Preliminaries - Stacks and Queues</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body>

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul class="collapse">
  <li><a href="#stacks" id="toc-stacks" class="nav-link active" data-scroll-target="#stacks"><span class="header-section-number">1</span> Stacks</a>
  <ul class="collapse">
  <li><a href="#stack-operations" id="toc-stack-operations" class="nav-link" data-scroll-target="#stack-operations"><span class="header-section-number">1.1</span> Stack Operations</a></li>
  <li><a href="#stack-uses" id="toc-stack-uses" class="nav-link" data-scroll-target="#stack-uses"><span class="header-section-number">1.2</span> Stack Uses</a></li>
  <li><a href="#stack-complexity" id="toc-stack-complexity" class="nav-link" data-scroll-target="#stack-complexity"><span class="header-section-number">1.3</span> Stack Complexity</a></li>
  </ul></li>
  <li><a href="#queues" id="toc-queues" class="nav-link" data-scroll-target="#queues"><span class="header-section-number">2</span> Queues</a>
  <ul class="collapse">
  <li><a href="#queue-operations" id="toc-queue-operations" class="nav-link" data-scroll-target="#queue-operations"><span class="header-section-number">2.1</span> Queue operations</a></li>
  <li><a href="#queue-complexity" id="toc-queue-complexity" class="nav-link" data-scroll-target="#queue-complexity"><span class="header-section-number">2.2</span> Queue complexity</a></li>
  <li><a href="#priority-queues" id="toc-priority-queues" class="nav-link" data-scroll-target="#priority-queues"><span class="header-section-number">2.3</span> Priority queues</a></li>
  </ul></li>
  <li><a href="#infix-to-postfix" id="toc-infix-to-postfix" class="nav-link" data-scroll-target="#infix-to-postfix"><span class="header-section-number">3</span> Infix to Postfix</a>
  <ul class="collapse">
  <li><a href="#converting-from-infix-to-postfix" id="toc-converting-from-infix-to-postfix" class="nav-link" data-scroll-target="#converting-from-infix-to-postfix"><span class="header-section-number">3.1</span> Converting from infix to postfix</a></li>
  <li><a href="#evaluating-postfix-expressions." id="toc-evaluating-postfix-expressions." class="nav-link" data-scroll-target="#evaluating-postfix-expressions."><span class="header-section-number">3.2</span> Evaluating postfix expressions.</a></li>
  <li><a href="#converting-from-infix-to-postfix-1" id="toc-converting-from-infix-to-postfix-1" class="nav-link" data-scroll-target="#converting-from-infix-to-postfix-1"><span class="header-section-number">3.3</span> Converting from infix to postfix</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Stacks and Queues</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<p>In this chapter, we are going to discuss two very useful data structures i.e.&nbsp;stacks and queues, both of which are applied in various places in Computer Science.</p>
<div class="callout callout-style-simple callout-none no-icon">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-body-container">
<p>Recall that in the discussion of abstract data types, we concentrate on the interface i.e.&nbsp;how we use the data structure, and are not overly concerned with the underlying implementation details (or data structures). That means that for the purposes of this particular lecture, we will be discussing top level functions. However, you will be required to design both a stack and queue for a future programming assignment and at that point, it will be up to you to figure out how to implement the functionality that wediscuss in today s lesson</p>
</div>
</div>
</div>
<section id="stacks" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Stacks</h1>
<p>Stacks as an abstract data type, are based on stacks in real life. For our discussions, it might prove helpful if you visualize a stack of books, or plates, or cards.A stack is a lection of homogeneous elements in which the addition and deletion of elements only occurs at one end i.e.&nbsp;the <strong>top</strong> of the stack. For example, if you had a stack of books, to get to the third book, you have to access the first, and then second, and always from the top. Creating the stack involves placing one element on top of another in such a way that the bottom element will always be the element that has spent the most time in the stack, and the top element will be the element that spends the shortest time in the stack. In fact, a stack is also referred to as a <strong>Last In First Out (LIFO)</strong> data structure.</p>
<section id="stack-operations" class="level2" data-number="1.1">
<h2 data-number="1.1" class="anchored" data-anchor-id="stack-operations"><span class="header-section-number">1.1</span> Stack Operations</h2>
<p>So what are the operations that the stack data structure supports?</p>
<p>Since we can add items to a stack, the stack data structure supports an add operation, typically referred to as <em>push</em>. We can also retrieve and remove the <em>top</em> element from a stack, and therefore the stack supports <em>top</em> and <em>pop</em> operations. <em>Top</em> retrieves the top element from the stack, and <em>pop</em> removes the top element from the stack. Alternative implementations combine this operation into <em>pop</em>, and then provide a <em>peek</em> function to retrieve the top elements information without removing it from the stack.</p>
<p>An element can only be added to a stack (<em>push</em>) if there is room, and an element can only be removed from the stack (<em>pop</em>) if there is something in the stack. This dictates the need for <em>IsEmpty</em> and <em>IsFull</em> functions. To know whether a stack IsFull, we’d need to know its size.</p>
<p>In summary, a stack should support the following functions:</p>
<ul>
<li>Push</li>
<li>Pop</li>
<li>Peek</li>
<li>Size</li>
<li>IsEmpty</li>
<li>IsFull</li>
</ul>
</section>
<section id="stack-uses" class="level2" data-number="1.2">
<h2 data-number="1.2" class="anchored" data-anchor-id="stack-uses"><span class="header-section-number">1.2</span> Stack Uses</h2>
<p>One of the most common uses of stacks in a computer is in keeping track of the functions that are called duing program execution. Suppose that your main calls function A, which calls B, which calls C, which calls D. When D terminates, control goes back to C. When C terminates, control goes back to B, and so on and so forth. You’ll notice that the order in which the functions were encountered is opposite to the order in which the control returns. A stack lends itself easily to such scenarios.</p>
<p>Another example of stack use is in reversing words. If the letters of the word are pushed onto a stack in the order in which they are encountered, then they can be popped of in the reverse order.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode default code-with-copy"><code class="sourceCode default"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>push R          //in what order will the word “RACECAR” be popped after being </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>push A          //pushed onto a stack?</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>push C</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>push E</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>push C</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>push A</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>push R</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>…</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>pop R</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>pop A</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>pop C</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>pop E</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>pop C</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>pop A</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>pop R</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Another example of stack use is in matching brackets. The way that works is if we follow this rule: push left parentheses, ignore operators and operands, and pop the stack whenever we get a right parenthesis to make a match.</p>
<p>See if you can follow the follow the input and stack umns for the expression <span class="math inline">\(a+b*(c+(d-e)/(f/g))\)</span></p>
<table class="table">
<thead>
<tr class="header">
<th>Input</th>
<th>Stack</th>
<th>Input</th>
<th>Stack</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>a</td>
<td></td>
<td>e</td>
<td>((</td>
</tr>
<tr class="even">
<td>+</td>
<td></td>
<td>)</td>
<td>(</td>
</tr>
<tr class="odd">
<td>b</td>
<td></td>
<td>/</td>
<td>(</td>
</tr>
<tr class="even">
<td>*</td>
<td></td>
<td>(</td>
<td>((</td>
</tr>
<tr class="odd">
<td>(</td>
<td>(</td>
<td>f</td>
<td>((</td>
</tr>
<tr class="even">
<td>c</td>
<td>(</td>
<td>/</td>
<td>((</td>
</tr>
<tr class="odd">
<td>+</td>
<td>(</td>
<td>g</td>
<td>((</td>
</tr>
<tr class="even">
<td>(</td>
<td>((</td>
<td>)</td>
<td>(</td>
</tr>
<tr class="odd">
<td>d</td>
<td>((</td>
<td>)</td>
<td></td>
</tr>
<tr class="even">
<td>-</td>
<td>((</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</section>
<section id="stack-complexity" class="level2" data-number="1.3">
<h2 data-number="1.3" class="anchored" data-anchor-id="stack-complexity"><span class="header-section-number">1.3</span> Stack Complexity</h2>
<p>The size of the data in a stack doesn’t affect how quickly we can perform a <em>push</em> or <em>pop</em> operation. As a result, the complexity for either one of those operations is <span class="math inline">\(O(1)\)</span>.</p>
</section>
</section>
<section id="queues" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Queues</h1>
<p>Another data structure, based off of what we see in real life, is the queue. While discussing this data structure it might help to envision an actual queue such as the one y’all would go through to get food in the cafeteria.</p>
<p>The general idea behind a queue is that the customer at the front of the line is the one who gets dealt with first, and whoever joins the queue joins it at the back of the line. As a result, a queue is also called a <strong>First In First Out (FIFO)</strong> data structure.</p>
<section id="queue-operations" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="queue-operations"><span class="header-section-number">2.1</span> Queue operations</h2>
<p>Similar to a stack, a queue is also a lection of homogeneous elements. However, the way that we interact with the queue is different. Elements are added to the queue from the back (enqueue) and are removed or deleted from the front of the queue (<em>dequeue</em>). Other than that, the operations that you would find in a stack are also found in a queue i.e.&nbsp;<em>Peek, Size, IsEmpty</em>, and <em>IsFull</em>.</p>
</section>
<section id="queue-complexity" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="queue-complexity"><span class="header-section-number">2.2</span> Queue complexity</h2>
<p>Similar to a stack, the process of enqueuing and dequeuing does not depend on the size of the data already stored in the queue. As a result, their complexity is <span class="math inline">\(O(1)\)</span>.</p>
</section>
<section id="priority-queues" class="level2" data-number="2.3">
<h2 data-number="2.3" class="anchored" data-anchor-id="priority-queues"><span class="header-section-number">2.3</span> Priority queues</h2>
<p>Sometimes first in, first out isn’t good enough. For example if you’ve just won the lottery and yet you’re stuck in a long line just to get to a ride at Disney world. Priority queues allow items to be ordered by a key. Each element is inserted into the queue at a position that is related to how important it is. The more important, the closer to the front that element is. Dequeuing is the same as in an ordinary queue with the element at the front of the queue removed first.</p>
<p>Because enqueuing requires finding the appropriate position for that element, enqueuing is now <span class="math inline">\(O(n)\)</span>, but dequeuing is still <span class="math inline">\(O(1)\)</span>.</p>
</section>
</section>
<section id="infix-to-postfix" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Infix to Postfix</h1>
<p>The usual notation for writing arithmetic expressions is called <strong>infix</strong> notation (because the operator is in between its operands). The operator (such as /) is written between the operands (such as 9 and 2).</p>
<pre><code>                                     9 + 6 / 3</code></pre>
<p>In infix, we evaluate from left to right. On top of that, multiplication and division have a higher precedence than addition and subtraction. If we want to enforce a different order, we include parentheses. So in the example above, we would evaluate the / before evaluating the +.</p>
<p>In the 1920s, a polish mathematician discovered that if we rearranged the operators and operands, then we wouldn’t need to use any parentheses. This method, called the <strong>prefix</strong> or <strong>Polish</strong> notation, places operators before the operands:</p>
<pre><code>                                    + a b</code></pre>
<p>In the 1950s, an australian philosopher and computer scientist proposed the opposite scheme, known as <strong>postfix</strong> or <strong>Reverse Polish</strong> notation. The postfix notation had the advantage that the operators appeared in the order required for their computation. Later on, it was realized that the postfix notation had great application in computer science. In fact, many compilers translate any arithmetic expression into postfix before translating it to machine code.</p>
<pre><code>                                   a b c * +</code></pre>
<p>Notice that with postfix, the operators are placed at the end, while with prefix, the operators are placed at the beginning.</p>
<p>We will soon see that when in postfix notation, a stack can be used to help in the evaluation of an arithmetic expression. Below is a table showing some basic infix expressions and what they would look like in postfix notation.</p>
<table class="table">
<thead>
<tr class="header">
<th>Infix expression</th>
<th>Postfix expression</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>a + b</code></td>
<td><code>a b +</code></td>
</tr>
<tr class="even">
<td><code>a + b * c</code></td>
<td><code>a b c * +</code></td>
</tr>
<tr class="odd">
<td><code>a * b + c</code></td>
<td><code>a b * c +</code></td>
</tr>
<tr class="even">
<td><code>(a + b) * c</code></td>
<td><code>a b + c *</code></td>
</tr>
<tr class="odd">
<td><code>(a - b) * (c + d)</code></td>
<td><code>a b - c d + *</code></td>
</tr>
<tr class="even">
<td><code>(a + b) * (c - d / e) + f</code></td>
<td><code>a b + c d e / - * f +</code></td>
</tr>
</tbody>
</table>
<section id="converting-from-infix-to-postfix" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="converting-from-infix-to-postfix"><span class="header-section-number">3.1</span> Converting from infix to postfix</h2>
<p>To convert from infix to postfix, we have to remember that:</p>
<ul>
<li>we carry out our evaluations from left to right</li>
<li>the operands should ALWAYS be in their original order</li>
<li>an operator should ALWAYS be placed after the operands on which it will operate. (it doesn’t have to be immediately after)</li>
</ul>
<p>It might be simple to see how to get from infix to postfix with short expressions but it gets complicated real quick with longer expressions. I suggest grouping and numbering different operations in order to guide you in converting from infix to postfix. <img src="images/lesson4.png" class="img-fluid"></p>
</section>
<section id="evaluating-postfix-expressions." class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="evaluating-postfix-expressions."><span class="header-section-number">3.2</span> Evaluating postfix expressions.</h2>
<p>As we mentioned earlier, we use a stack to evaluate postfix expressions. But how exactly? We go through the postfix expression from left to right. If we encounter an operand, we push it onto the stack. However, If we encounter an operator, we pop the top two items from the stack, evaluate it, and push the result back onto the stack.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode default code-with-copy"><code class="sourceCode default"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>a = Pop();</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>b = Pop();</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>Push(eval(a, b));</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>For example, if our postfix expression was <code>5 2 9 * +</code></p>
<table class="table">
<thead>
<tr class="header">
<th>input</th>
<th>stack</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>5</code></td>
<td><code>5</code></td>
</tr>
<tr class="even">
<td><code>2</code></td>
<td><code>2 5</code></td>
</tr>
<tr class="odd">
<td><code>9</code></td>
<td><code>9 2 5</code></td>
</tr>
<tr class="even">
<td><code>*</code></td>
<td><code>18 5</code></td>
</tr>
<tr class="odd">
<td><code>+</code></td>
<td><code>23</code></td>
</tr>
</tbody>
</table>
<p>Alternatively, if our expression was <code>7 5 + 9 * 6 +</code></p>
<table class="table">
<thead>
<tr class="header">
<th>input</th>
<th>stack</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>7</code></td>
<td><code>7</code></td>
</tr>
<tr class="even">
<td><code>5</code></td>
<td><code>5 7</code></td>
</tr>
<tr class="odd">
<td><code>+</code></td>
<td><code>12</code></td>
</tr>
<tr class="even">
<td><code>9</code></td>
<td><code>9 12</code></td>
</tr>
<tr class="odd">
<td><code>*</code></td>
<td><code>108</code></td>
</tr>
<tr class="even">
<td><code>6</code></td>
<td><code>6 108</code></td>
</tr>
<tr class="odd">
<td><code>+</code></td>
<td><code>114</code></td>
</tr>
</tbody>
</table>
</section>
<section id="converting-from-infix-to-postfix-1" class="level2" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="converting-from-infix-to-postfix-1"><span class="header-section-number">3.3</span> Converting from infix to postfix</h2>
<p>Both stacks and queues can be used to convert an expression from infix to postfix.</p>
<p>The infix expression is read out of a queue, and the postfix expression is stored in another queue. The operands are transferred from the infix queue to the postfix queue in their proper order. However, operators are stored on a stack and then removed and put into the postfix queue in their appropriate position.</p>
<p>So what exactly determines the appropriate position of an operator? Its position is dependent on arithmetic hierarchy of operators and is used to determine how long the operator will remain on the stack before being popped and enqueued to the postfix queue.</p>
<p>For example, we can rank operators that we would expect to find in an infix expression.</p>
<table class="table">
<thead>
<tr class="header">
<th>Token</th>
<th>(</th>
<th>^</th>
<th>*</th>
<th>/</th>
<th>+</th>
<th>-</th>
<th>default</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Value</td>
<td>4</td>
<td>3</td>
<td>2</td>
<td>2</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>The ranking above puts priority on parentheses and exponents.</p>
<p>We can also rank operators that we would find in a postfix expression.</p>
<table class="table">
<thead>
<tr class="header">
<th>Token</th>
<th>^</th>
<th>*</th>
<th>/</th>
<th>+</th>
<th>-</th>
<th>default</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Value</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>The ranking above reflects the idea that our postfix expression would not have parentheses. Otherwise it looks exactly the same as the one before except that ^ no longer has as high of a value. This is to make sure that if we come across a ^ in the infix expression, it has a higher priority than a ^ that might be on the stack. If they were the same rank, then the expression <br> <br> &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>2 ^ 3 ^ 2</code></p>
<p>would have the same answer whichever way you evaluated it. As it turns out, <code>(2^3)^2</code> gives a different answer from <code>2^(3^2)</code> and the correct one is the latter i.e.&nbsp;512.</p>
<p>The actual algorithm for converting from infix to postfix is given below.</p>
<p>We shall use it to convert a few examples of expressions and hopefully it’ll become clearer.</p>
<p>The expression that we will convert is <code>3 * 4 - ( 7 – 8 / 2 )</code></p>
<div class="sourceCode" id="cb6"><pre class="sourceCode default code-with-copy"><code class="sourceCode default"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>    infixQ ← infix expression</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    postfixQ ← empty queue</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    operS ← empty stack</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    repeat</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>        token ← infixQ.dequeue()</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>        if token is an operand</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>        then</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>            postfixQ.enqueue(token)</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>        else if token is a right parenthesis</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>        then</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>            op ← operS.pop()</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>            while op is not a left parenthesis</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>                postfixQ.enqueue(op)</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>                op ← operS.pop()</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>            end</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>        else</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>            op ← operS.peek()</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>            while stack_priority(op) &gt;= infix_priority(token)</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>                op ← operS.pop()</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>                postfixQ.enqueue(op)</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>                op ← operS.peek()</span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>            end</span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>            operS.push(token)</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>        end</span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>    until infixQ is empty</span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>    while operS is not empty</span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>        op ← operS.pop()</span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>        postfixQ.enqueue(op)</span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>    end</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<table class="table">
<thead>
<tr class="header">
<th>Infix queue</th>
<th>token</th>
<th>Operator stack</th>
<th>Postfix queue</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>3 * 4 - ( 7 – 8 / 2 )</code></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><code>* 4 - ( 7 – 8 / 2 )</code></td>
<td><code>3</code></td>
<td></td>
<td><code>3</code></td>
</tr>
<tr class="odd">
<td><code>4 - ( 7 – 8 / 2 )</code></td>
<td><code>*</code></td>
<td><code>*</code></td>
<td><code>3</code></td>
</tr>
<tr class="even">
<td><code>- ( 7 – 8 / 2 )</code></td>
<td><code>4</code></td>
<td><code>*</code></td>
<td><code>3 4</code></td>
</tr>
<tr class="odd">
<td><code>( 7 – 8 / 2 )</code></td>
<td><code>-</code></td>
<td><code>-</code></td>
<td><code>3 4 *</code></td>
</tr>
<tr class="even">
<td><code>7 – 8 / 2 )</code></td>
<td><code>(</code></td>
<td><code>( -</code></td>
<td><code>3 4 *</code></td>
</tr>
<tr class="odd">
<td><code>– 8 / 2 )</code></td>
<td><code>7</code></td>
<td><code>( -</code></td>
<td><code>3 4 * 7</code></td>
</tr>
<tr class="even">
<td><code>8/ 2)</code></td>
<td><code>-</code></td>
<td><code>- ( -</code></td>
<td><code>3 4 * 7</code></td>
</tr>
<tr class="odd">
<td><code>/ 2)</code></td>
<td><code>8</code></td>
<td><code>- ( -</code></td>
<td><code>3 4 * 7 8</code></td>
</tr>
<tr class="even">
<td><code>2)</code></td>
<td><code>/</code></td>
<td><code>/ - ( -</code></td>
<td><code>3 4 * 7 8</code></td>
</tr>
<tr class="odd">
<td><code>)</code></td>
<td><code>2</code></td>
<td><code>/ - ( -</code></td>
<td><code>3 4 * 7 8 2</code></td>
</tr>
<tr class="even">
<td></td>
<td><code>)</code></td>
<td><code>-</code></td>
<td><code>3 4 * 7 8 2 / -</code></td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td></td>
<td><code>3 4 * 7 8 2 / - -</code></td>
</tr>
</tbody>
</table>
<p>And therefore the final postfix expression is <code>3  4 * 7 8 2 / - -</code></p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>