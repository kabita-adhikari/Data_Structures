<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Java Preliminaries - List Processing</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body>

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#insertion" id="toc-insertion" class="nav-link active" data-scroll-target="#insertion"><span class="header-section-number">1</span> Insertion</a></li>
  <li><a href="#deletion" id="toc-deletion" class="nav-link" data-scroll-target="#deletion"><span class="header-section-number">2</span> Deletion</a></li>
  <li><a href="#searching" id="toc-searching" class="nav-link" data-scroll-target="#searching"><span class="header-section-number">3</span> Searching</a></li>
  <li><a href="#sorting" id="toc-sorting" class="nav-link" data-scroll-target="#sorting"><span class="header-section-number">4</span> Sorting</a>
  <ul>
  <li><a href="#bubble-sort" id="toc-bubble-sort" class="nav-link" data-scroll-target="#bubble-sort"><span class="header-section-number">4.1</span> Bubble Sort</a></li>
  <li><a href="#selection-sort" id="toc-selection-sort" class="nav-link" data-scroll-target="#selection-sort"><span class="header-section-number">4.2</span> Selection Sort</a></li>
  <li><a href="#insertion-sort" id="toc-insertion-sort" class="nav-link" data-scroll-target="#insertion-sort"><span class="header-section-number">4.3</span> Insertion Sort</a></li>
  </ul></li>
  <li><a href="#recap" id="toc-recap" class="nav-link" data-scroll-target="#recap"><span class="header-section-number">5</span> Recap</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">List Processing</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<p>So we’ve programmed the easylist which used an array for its implementation. Now we have the background to discuss some of the common manipulations that are used on list and how efficient they are. Recall that the whole reason behind data structures is to arrange data in such a way that it can be manipulated efficiently. What exactly is a list anyway? It is a set of values of the same type, and as we’ve seen, arrays are perfect for storing such kinds of data. As you may have noticed before, many data structures in computer science are based on methods of arrangement that occur in real life, and lists are not an exception. If you ever get confused, just visualize a physical list e.g.&nbsp;a shopping list like the one you’d use to buy groceries. Now we know how it looks like, what kind of operations/manipulations do we typically do with a list? - Insert an item in the list - delete an item from the list - search the list - sort the list</p>
<section id="insertion" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="insertion"><span class="header-section-number">1</span> Insertion</h2>
<p>This is a very basic operation for a list: We just insert an item at the end of the list. This operation doesn’t depend on how many items (or pieces of data) are already in the list. Therefore its complexity in the big-O notation is <span class="math inline">\(O(1)\)</span>.</p>
</section>
<section id="deletion" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="deletion"><span class="header-section-number">2</span> Deletion</h2>
<p>Deleting an item from a list is slightly more involved. We first have to search for the item that we have to delete, delete it, and then shift the remaining elements to cover up the space we just freed up. Its complexity is <span class="math inline">\(O(n)\)</span> because the process grows linearly with the size of data that you are dealing with. On average, we’ll compare <span class="math inline">\(\frac{n}{2}\)</span> items, and shift <span class="math inline">\(\frac{n}{2}\)</span> items to the left.</p>
</section>
<section id="searching" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="searching"><span class="header-section-number">3</span> Searching</h2>
<p>To search through our list, we need three things: the list itself, its length, and the item for which we are going to search. Typical search algorithms will return <span class="math inline">\(a -1\)</span> if the value for which we are searching is not found. If the value is found, it will return the index of the item. There are different kinds of searching algorithms that you can employ on your list.The most basic is the <strong>linear</strong> or <strong>sequential search</strong>. It starts at the beginning of the array and searches until either we find the item, or we reach the end of the array</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode default code-with-copy"><code class="sourceCode default"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>//Sequential/Linear Search</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>int LinearSearch(int [] list, int item)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    for(int i=0; i&lt;list.length; i++)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    {</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>        if(list[i] == item)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>            return i;</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    return -1;</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>So what about the performance of this search? Imagine our list has 1000 items. If the item we are searching for is near the front, the search will be fast, but if its near the end of the list, the search will be long.</p>
<p>Its complexity is <span class="math inline">\(O(n)\)</span>. On average, we’ll compare <span class="math inline">\(\frac{n}{2}\)</span> items.</p>
<p>So how can it be improved? Well if the list was ordered, then we wouldn’t have to search all the way to the end to figure out that the key we were searching for wasn’t in the list. We would know that a key isn’t in the list as soon as we found value larger (or smaller…depending on how your list is ordered) than the key we were looking for.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode java code-with-copy"><code class="sourceCode java"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">//Ordered Sequential/Linear Search</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="fu">OrderedLinearSearch</span><span class="op">(</span><span class="dt">int</span> <span class="op">[]</span> list<span class="op">,</span> <span class="dt">int</span> item<span class="op">)</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span> i<span class="op">&lt;</span>list<span class="op">.</span><span class="fu">length</span><span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>list<span class="op">[</span>i<span class="op">]</span> <span class="op">==</span> item<span class="op">)</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> i<span class="op">;</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>list<span class="op">[</span>i<span class="op">]</span> <span class="op">&gt;</span> item<span class="op">)</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>If the list was ordered, we could also employ a binary search which is a slightly more complicated algorithm but would perform much faster.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode java code-with-copy"><code class="sourceCode java"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">//Binary Search</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="fu">BinarySearch</span><span class="op">(</span><span class="dt">int</span> <span class="op">[]</span> list<span class="op">,</span> <span class="dt">int</span> item<span class="op">)</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> first <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> last <span class="op">=</span> list<span class="op">.</span><span class="fu">length</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> mid<span class="op">;</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span><span class="op">(</span>first <span class="op">&lt;=</span> last<span class="op">)</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>        mid <span class="op">=</span> <span class="op">(</span>first <span class="op">+</span> last<span class="op">)</span> <span class="op">/</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>list<span class="op">[</span>mid<span class="op">]</span> <span class="op">==</span> item<span class="op">)</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> mid<span class="op">;</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>list<span class="op">[</span>mid<span class="op">]</span> <span class="op">&gt;</span> item<span class="op">)</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>            last <span class="op">=</span> mid – <span class="dv">1</span><span class="op">;</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>            first <span class="op">=</span> mid <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>What is the complexity for a binary search? <span class="math inline">\(O(log n)\)</span>. Just so you remember, the division to find the mid is integer division. For example, if the list had 100 elements (indices 0 to 99), then mid would evaluate to <span class="math inline">\(\frac{99}{2} =49\)</span></p>
</section>
<section id="sorting" class="level2" data-number="4">
<h2 data-number="4" class="anchored" data-anchor-id="sorting"><span class="header-section-number">4</span> Sorting</h2>
<p>Another common operation for lists is sorting them. Why? Did you see how much faster a binary search is than a sequential search? If you are going to be doing a lot of searching on your list, it makes sense to sort them at the beginning so that you can save on time when it comes to searching.Alternatively, if you are going to be doing very little searching in your list, then maybe sorting would take up too much time.</p>
<p>So how do we sort? Its very easy for us as humans to do with small data sizes because we can see multiple pieces of data at the same time, do loads of comparisons in a short time, etc. But what about a computer? Is there a way that we can design an algorithm to sort the data in a sequence of steps that will always work regardless of how the data looks in the first place?</p>
<div class="callout callout-style-default callout-important no-icon callout-titled" title="Activity">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Activity
</div>
</div>
<div class="callout-body-container callout-body">
<p>Let’s see if you can sort the provided playing cards in non-descending order. Now can you figure out a sequence of steps to describe the process you just went through? A sequence that will always work?</p>
</div>
</div>
<section id="bubble-sort" class="level3" data-number="4.1">
<h3 data-number="4.1" class="anchored" data-anchor-id="bubble-sort"><span class="header-section-number">4.1</span> Bubble Sort</h3>
<div class="sourceCode" id="cb4"><pre class="sourceCode java code-with-copy"><code class="sourceCode java"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">//Bubble Sort</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">BubbleSort</span><span class="op">(</span><span class="dt">int</span> <span class="op">[]</span> list<span class="op">)</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span> i<span class="op">&lt;</span>list<span class="op">.</span><span class="fu">length</span><span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> j<span class="op">=</span><span class="dv">1</span><span class="op">;</span> j<span class="op">&lt;</span>list<span class="op">.</span><span class="fu">length</span><span class="op">-</span>i<span class="op">+</span><span class="dv">1</span><span class="op">;</span> j<span class="op">++)</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(</span>list<span class="op">[</span>j<span class="op">]</span> <span class="op">&lt;</span> list<span class="op">[</span>j<span class="op">-</span><span class="dv">1</span><span class="op">])</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>            <span class="op">{</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>                <span class="dt">int</span> temp <span class="op">=</span> list<span class="op">[</span>j<span class="op">];</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>                list<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> list<span class="op">[</span>j<span class="op">-</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>                list<span class="op">[</span>j<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> temp<span class="op">;</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Let’s assume that we want to sort the list in increasing order. Bubble sort works by making successive swaps in such a way as to move the largest element to the endof the array. That way the larger values “bubble” to the end of the array.</p>
<p>The inner loop affects a single <strong>pass</strong> through the list, and controls how many comparisons are carried out in each pass.</p>
<p>The outer loop controls the number of <strong>passes</strong> through the array.</p>
<p>To sort a list of <span class="math inline">\(n\)</span> elements, this algorithm will take <span class="math inline">\(n-1\)</span> passes.</p>
<p>In each pass, it will make between <span class="math inline">\(n-1\)</span> and comparisons. This totals up to <span class="math inline">\(\frac{n(n−1)}{2}\)</span> comparisons. On average, only half of those comparisons will result in a swap, i.e.&nbsp;<span class="math inline">\(\frac{n(n−1)}{4}\)</span> swaps. This means that for a list of 1000 elements, bubble sort would require about 500,000 comparisons, and 250,000 swaps on average. This represents a complexity of <span class="math inline">\(O(n^2)\)</span>.</p>
<table class="table">
<colgroup>
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 45%">
<col style="width: 5%">
</colgroup>
<thead>
<tr class="header">
<th>Pass</th>
<th>Comparisons</th>
<th>List</th>
<th>Indices Compared</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td></td>
<td></td>
<td><u>9 5 7 1 3</u></td>
<td></td>
</tr>
<tr class="even">
<td>1</td>
<td>4</td>
<td><u>5 7 1 3</u> 9</td>
<td><span class="math inline">\(0/1, 1/2, 2/3, 3/4\)</span></td>
</tr>
<tr class="odd">
<td>2</td>
<td>3</td>
<td><u>5 1 3 </u>7 9</td>
<td><span class="math inline">\(0/1, 1/2, 2/3\)</span></td>
</tr>
<tr class="even">
<td>3</td>
<td>2</td>
<td><u>1 3</u> 5 7 9</td>
<td><span class="math inline">\(0/1, 1/2\)</span></td>
</tr>
<tr class="odd">
<td>4</td>
<td>1</td>
<td>1 3 5 7 9</td>
<td><span class="math inline">\(0/1\)</span></td>
</tr>
</tbody>
</table>
<p>One of the weaknesses with the bubble sort is that even if the input is already sorted, it will still go through all the passes before ending.Fortunately, there is a way to make it optimized.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode java code-with-copy"><code class="sourceCode java"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">//Optimized Bubble Sort</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">OptimizedBubbleSort</span><span class="op">(</span><span class="dt">int</span> <span class="op">[]</span> list<span class="op">)</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">boolean</span> swapMade<span class="op">;</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span> i<span class="op">&lt;</span>list<span class="op">.</span><span class="fu">length</span><span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>        swapMade <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> j<span class="op">=</span><span class="dv">1</span><span class="op">;</span> j<span class="op">&lt;</span>list<span class="op">.</span><span class="fu">length</span><span class="op">-</span>i<span class="op">+</span><span class="dv">1</span><span class="op">;</span> j<span class="op">++)</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(</span>list<span class="op">[</span>j<span class="op">]</span> <span class="op">&lt;</span> list<span class="op">[</span>j<span class="op">-</span><span class="dv">1</span><span class="op">])</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>            <span class="op">{</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>                <span class="dt">int</span> temp <span class="op">=</span> list<span class="op">[</span>j<span class="op">];</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>                list<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> list<span class="op">[</span>j<span class="op">-</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>                list<span class="op">[</span>j<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> temp<span class="op">;</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>                swapMade <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(!</span>swapMade<span class="op">)</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="selection-sort" class="level3" data-number="4.2">
<h3 data-number="4.2" class="anchored" data-anchor-id="selection-sort"><span class="header-section-number">4.2</span> Selection Sort</h3>
<p>Selection sort works by identifying the smallest element in the list, and placing it in the first position (using a single swap). It then starts at the second position and finds the next-smallest item and places it in the second position (also using a single swap). It does this process repeatedly: finding the smallest item in the unsorted part of the list, and placing it in its proper position in the sorted part of the list. The left side of the list is the sorted part, and the right hand side is the unsorted part.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode java code-with-copy"><code class="sourceCode java"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co">//Selection Sort</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">SelectionSort</span><span class="op">(</span><span class="dt">int</span> <span class="op">[]</span> list<span class="op">)</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span> i<span class="op">&lt;</span>list<span class="op">.</span><span class="fu">length</span><span class="op">-</span><span class="dv">1</span><span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> minIndex <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> j<span class="op">=</span>i<span class="op">+</span><span class="dv">1</span><span class="op">;</span> j<span class="op">&lt;</span>list<span class="op">.</span><span class="fu">length</span><span class="op">;</span> j<span class="op">++)</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span><span class="op">(</span>list<span class="op">[</span>j<span class="op">]</span> <span class="op">&lt;</span> list<span class="op">[</span>minIndex<span class="op">])</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>                minIndex <span class="op">=</span> j<span class="op">;</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> temp <span class="op">=</span> list<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>        list<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> list<span class="op">[</span>minIndex<span class="op">];</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>        list<span class="op">[</span>minIndex<span class="op">]</span> <span class="op">=</span> temp<span class="op">;</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>On average, for a list of size n, it still requires <span class="math inline">\(\frac{n(n−1)}{2}\)</span> comparisons, but only <span class="math inline">\((n−1)\)</span> swaps which is considerably less than the bubble sort that we looked at earlier. For example, a list of 1000 elements would require approximately 500,000 key comparisons, but only 1000 swaps.</p>
<p>Its complexity is still <span class="math inline">\(O(n^2)\)</span>.</p>
<p>Its useful with small amounts of data, in particular when swapping is time consuming.</p>
<table class="table">
<thead>
<tr class="header">
<th>Pass</th>
<th>Comparisons</th>
<th>List</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td></td>
<td></td>
<td>9 <u>5 7 1 3</u></td>
</tr>
<tr class="even">
<td>1</td>
<td>4</td>
<td>1 5 <u>7 9 3</u></td>
</tr>
<tr class="odd">
<td>2</td>
<td>3</td>
<td>1 3 7 <u>9 5</u></td>
</tr>
<tr class="even">
<td>3</td>
<td>2</td>
<td>1 3 5 9 <u>7</u></td>
</tr>
<tr class="odd">
<td>4</td>
<td>1</td>
<td>1 3 5 7 9</td>
</tr>
</tbody>
</table>
</section>
<section id="insertion-sort" class="level3" data-number="4.3">
<h3 data-number="4.3" class="anchored" data-anchor-id="insertion-sort"><span class="header-section-number">4.3</span> Insertion Sort</h3>
<p>Insertion sort is the kind of sorting that we typically use as humans. We assume that the first part of the list is sorted, and the latter part is unsorted. We then move one item at a time from the unsorted part to the sorted part making sore to put it in its right position in order to maintain the “sortedness” of the sorted part.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode java code-with-copy"><code class="sourceCode java"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co">//Insertion Sort</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">InsertionSort</span><span class="op">(</span><span class="dt">int</span> <span class="op">[]</span> list<span class="op">)</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span> i<span class="op">&lt;</span>list<span class="op">.</span><span class="fu">length</span><span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span><span class="op">(</span>list<span class="op">[</span>i<span class="op">]</span> <span class="op">&lt;</span> list<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">])</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> j<span class="op">,</span> temp <span class="op">=</span> list<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span><span class="op">(</span>j<span class="op">=</span>i<span class="op">-</span><span class="dv">1</span><span class="op">;</span> j<span class="op">&gt;=</span><span class="dv">0</span> <span class="op">&amp;&amp;</span> list<span class="op">[</span>j<span class="op">]&gt;</span>temp<span class="op">;</span> j<span class="op">--)</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>                list<span class="op">[</span>j<span class="op">+</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> list<span class="op">[</span>j<span class="op">];</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>            list<span class="op">[</span>j<span class="op">+</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> temp<span class="op">;</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>On average, for a list of size n, it takes <span class="math inline">\(\frac{n(n−1)}{2}\)</span> comparisons, and <span class="math inline">\(\frac{n(n−1)}{4}\)</span> swaps which amounts to a complexity of <span class="math inline">\(O(n^2)\)</span>. However, with an almost sorted list, it takes almost <span class="math inline">\(O(n)\)</span>. This means that it is the best algorithm to use for an almost sorted list.</p>
<table class="table">
<colgroup>
<col style="width: 25%">
<col style="width: 75%">
</colgroup>
<thead>
<tr class="header">
<th>Pass</th>
<th>List</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td></td>
<td>9 <u>5 7 1 3</u></td>
</tr>
<tr class="even">
<td>1</td>
<td>5 9 <u>7 1 3</u></td>
</tr>
<tr class="odd">
<td>2</td>
<td>5 7 9 <u>1 3</u></td>
</tr>
<tr class="even">
<td>3</td>
<td>1 5 7 9 <u>3</u></td>
</tr>
<tr class="odd">
<td>4</td>
<td>1 3 5 7 9</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="recap" class="level2" data-number="5">
<h2 data-number="5" class="anchored" data-anchor-id="recap"><span class="header-section-number">5</span> Recap</h2>
<ul>
<li>For each sort, sorting n elements takes n-1 passes.</li>
<li>Each sort maintains a sorted and unsorted side.
<ul>
<li>Bubble: unsorted = left, sorted = right</li>
<li>Select: unsorted = right, sorted = left</li>
<li>Insertion: unsorted = right, sorted = left</li>
</ul></li>
<li>A single element is trivially sorted.</li>
<li>To differentiate between the different kinds of sorts
<ul>
<li>Bubble: on each pass, largest item in unsorted side “bubbles” to end of unsorted side. Requires many swaps, and many comparisons.</li>
<li>Select: on each pass, smallest item in unsorted side moves to beginning of unsorted side. Requires few swaps, but many comparisons.</li>
<li>Insertion: on each pass, first item in unsorted side moves to its proper place in sorted side. Some swaps, some comparisons.</li>
</ul></li>
<li>Sequential search on an ordered list can abort search early if current element is greater than the key we are searching for. On average, it takes <span class="math inline">\(\frac{n}{2}\)</span> key comparisons but is a bit better than sequential search on an un-ordered list. On the down side, insertion into an ordered list is more costly. Complexity of a sequential search is <span class="math inline">\(O(n)\)</span>.</li>
<li>Binary search can only be used when the list is sorted. It uses a divide and conquer technique. It is usually applied to array based lists since its easy to find the middle element <span class="math inline">\((\frac{first+last}{2})\)</span> . If the middle element is what we are searching for, then we’re done. If its less than what we are searching for, we search in the list to the right, otherwise, we search in the list to the left. We keep on repeating this process till we find the key (or don’t find it). Complexity of binary search is <span class="math inline">\(O(lg n)\)</span>.</li>
</ul>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>