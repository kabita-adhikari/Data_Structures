[
  {
    "objectID": "lesson6.html",
    "href": "lesson6.html",
    "title": "Binary Trees",
    "section": "",
    "text": "The highest priority when a programmer is organizing data is making sure that item insertions, deletion, and searches are fast. The first structure that we considered was an array. Insertion and deletion were quick but searches were not. This weakness becomes even more pronounced with larger data sizes.\nThe next idea was to sort the array i.e. an ordered array. That way we could employ binary searches which made the searching way faster. However, Insertions and deletions became slower as a result. This is because we would have to expand and collapse the list respectively, both of which required data movement, and that is an expensive step particularly for larger data sizes.\nTo speed up insertions and deletions, we turned to linked lists. Insertion and deletion in a linked list did not require any major data movement; we simply adjusted a few nodes in the list. However, the draw back for linked lists is that they must be processed sequentially i.e. we had to traverse from the head in their proper order to find or process any node. So even though the insertion and deletion didn’t require much data movement, we had to begin our searches at the first node in the list every time.\nThe next data structure that we will discuss is the binary tree which attempts to combine the best features of arrays and linked lists i.e. it allows quick searching (like in an ordered array), but also allow fast insertion and deletion (like a linked list)"
  },
  {
    "objectID": "lesson5a.html",
    "href": "lesson5a.html",
    "title": "5(a). Recursion",
    "section": "",
    "text": "To understand recursion, you must understand recursion!\n\n\n\nOne of the most common techniques used during the deriving of solutions to problems is iteration. There are some cases, however, where using an iterative approach is overly complicated. In some of those cases, it is significantly easier touse recursion.\n\n1 Recursive definitions\nRecursion is all about solving a problem by breaking it down into smaller versions of itself. To explain this concept, let us consider factorials.\nMathematically speaking, a factorial of a non-negative integer is defined with two equations below:\n0! = 1           ----------&gt;①\nn! = n x (n-1)!  ----------&gt;②\nEquation ① says that the factorial of 0 is equal to 1, while equation ② says that the factorial of any number n is equal to the product of n and the factorial of n-1. You’ll notice that even though we have a factorial in our definition of factorial, it is a reduced or smaller version of itself i.e. n-1. Using this definition, we see that\n3! = 3 x 2!\nBut 2! = 2 x 1!\nand 1! = 1 x 0!\nand 0! = 1.\nWorking backwards gives us\n1! = 1 x 1 = 1\n2! = 2 x 1 = 2\nand 3! = 3 x 2 = 6\nOne thing to realize for this technique to work, we need a direct easy case called the base case, which in this case is equation ①. The other condition for this technique to work is that we need the general case which breaks down our solution to a simpler version of itself.\nTo recap:\n\nThe recursive definition must have at least one base case.\nhe general case must eventually be reduced to a base case, and\nThe base case stops the recursion.\n\nAn algorithm that finds a solution to a problem by reducing it to smaller versions of itself is called a recursive algorithm. And in computer science, a function that calls itself is called a recursive function i.e. the body of the function should have a statement that causes the same function to execute again before completing the current call.\nLet’s see what the factorial algorithm defined above would look like as a recursive function.\nint fact(int num)\n{\n    if (num == 0)\n        return 1;\n    else\n        return num * fact(num – 1);\n}\n\n\n2 Designing recursive functions\nTo design a recursive function, you must do the following:\n\nUnderstand the problem requirements\nDetermine the limiting conditions\nIdentify the base case and its direct solution\nIdentify the general case and a solution to it which utilizes a smaller version of itself.\n\n\n\n\n\n\n\nWrite a recursive function to evaluate the exponent of one integer. Its signature is given below:\nint pow(int x, int n)    //It should return xn.\n\n\n\n\n\n\n\n\n\nWrite a recursive function to return the nth fibonacci number.\nThe fibonacci sequence can be represented using the following mathematical description.\nFib(n) =0                   if n = 0;\n        1                   if n = 1;\n        Fib(n-1) + Fib(n-2) if n &gt; 1.\n\n\n\nFor most cases, one can write either a recursive or normal iterative function to solve a task. There are however cases where the recursive approach is significantly easier.\nLet’s look at traversing a linked list from a previous lecture. The code that was provided in that lecture looked like the one below.\nvoid Traverse(Node n)\n{\n    while (n != NULL)\n    {\n        System.out.print(n.getData() + “ “);\n        n = n.getLink();\n    }\n    System.out.println();\n}\n/* and the function would be called using a statement like:\nTraverse(head);\n*/\nA function to traverse the list could be written in a recursive manner as well.\nvoid Traverse(Node n)\n{\n    if (n == NULL)\n        return;\n    System.out.print(n.getData() + “ “);\n    Traverse(n.getLink());\n}\nAs you can see, the base case is when the list is null in which case we return nothing. Otherwise, we output the data portion of the node in which we are, and then call the same function starting at the next node in the sequence. Notice that in the iterative approach, once we move on to the next node, there is no way to get back since our variable n would have changed. However, in the recursive approach, since the function calls a copy of itself which has access to the next node, we technically still have access to the entire list. Recall that the function will not terminate until all function calls under it have been terminated. This means that we will have multiple copies of the Traverse function, each of which will have access to the list at the same time (even though we are only in one function at a time, and all the rest are kinda “on pause”). We can take advantage of this feature to print the list backward starting with the tail. To do this, we just make sure to do any processing of the nodes (such as the printing), on the way back from the base case. We do this by reversing the order of the processing and recursive call.\nvoid Traverse(Node n)\n{\n    if (n == NULL)\n        return;\n    Traverse(n.getLink());\n    System.out.print(n.getData() + “ “);\n}\n\n\n3 Towers of Hanoi\nThe towers of Hanoi is probably the most famous example of a problem that would be solved by recursion. Towers of Hanoi is a game that involves moving different size disks from one peg to another. It typically involves 5 disks and 3 pegs. The only rule is that during the moving process, you can only move one diskat a time, and you can never place a larger disk on top of a smaller disk.\nI will not go into too much detail about this game and or topic given that it was covered in CSC/CYEN 131.\nvoid Hanoi(int n, char from, char to, char spare)\n{\n    if (n == 1)\n    {\n        System.out.println(from + “ -&gt; “ + to);\n        return;\n    }\n    Hanoi(n-1, from, spare, to);\n    Hanoi(1, from, to, spare);\n    Hanoi(n-1, spare, to, from);\n}\n\n\n\n\n\n\nSo how many moves are required for 5 disks? 10 disks? What about 64 disks? The origin story about towers of Hanoi says that some priests have been solving a 64 disktower of Hanoi problem and that the world will end when they finally do. If moving each disk took only 1 second, what s the shortest time it would it take to solve the ’ 64 disk problem?"
  },
  {
    "objectID": "lesson3.html",
    "href": "lesson3.html",
    "title": "Linked Lists",
    "section": "",
    "text": "Abstract data types are ways of representing abstract information. Its basically a specification of a set of data, and a set of possible operations that can be performed on that data. They are meant to be a representation of certain types of data from the point of view of the user of this data.\nFor example, we’ve just completed the EasyList assignment in which we created a list data type. In the back end, we used an array to store this list. However, on the front end (in the ListTest.java), we only had access to specific functions and methods that allowed us to manipulate the list in specific ways.\nSo a list is an example of an abstract data type. In our assignment, it only stored integers (so its set of data is integers), and the possible operations that we could perform on that data were deletion, insertion, initialization, e.t.c.\nTypical list operations include - initialization - determining whether the list is empty - displaying the list - finding the length of the list - retrieving information stored in the first element - retrieving information stored in the last element - searching the list for a given item - inserting an item into the list - deleting an item from the list - making a copy of the list In that assignment, we used arrays to implement the backend of this abstract data type but there are some shortcomings with that approach, chief of which is the inability of the list to grow to whatever size is necessary. Recall that we had a maximum size of the array, and that even if our list had fewer items, the computer technically had set aside the maximum size for our list. Additionally, if our list was full, there was no way to increase its size during run time.\nAnother way of implementing the list is using what are referred to as linked lists. These lists use references ( referred to as pointers in other languages), to allow the list to grow and/or shrink as needed. Additionally, linked lists don’t have to be stored in contiguous memory locations."
  },
  {
    "objectID": "lesson3.html#adding-a-node-to-the-list",
    "href": "lesson3.html#adding-a-node-to-the-list",
    "title": "Linked Lists",
    "section": "2.1 Adding a node to the list",
    "text": "2.1 Adding a node to the list\nLet’s see how we would create the list and add a node to it, and how it would look like diagrammatically.\n\n\n\n\n\n\n\n\nCode\nDiagram\n\n\n\n\nNode head;                 Node curr;\n\n\n\nhead = new Node();\n\n\n\nhead.setData(17);\n\n\n\ncurr = head;\n\n\n\ncurr.setLink(new Node());      curr = curr.getLink();      curr.setData(10);\n\n\n\ncurr.setLink(new Node());     curr.getLink().setData(15);\n\n\n\ncurr.getLink().setLink(new Node());     curr.getLink().getLink().set     Data(32);\n\n\n\ncurr =      curr.getLink().getLink();\n\n\n\n\n\nA few things to note about the code and diagrams above. - One creates a new node using the new keyword. - The links are one direction i.e. the address of the second is stored in the first, the address of the third is stored in the second, etc. Once the pointer has moved to the next node, there is no way of going back to the previous node unless you had either stored its value somewhere else, or you began from head again."
  },
  {
    "objectID": "lesson3.html#traversing-the-list",
    "href": "lesson3.html#traversing-the-list",
    "title": "Linked Lists",
    "section": "2.2 Traversing the list",
    "text": "2.2 Traversing the list\nRecall that we can only move down the list in one direction. Typically, the link of the last node of the linked list will be null. We can use these properties to traverse the list. This comes in handy in scenarios, such as when one wants to print out the contents of the list starting with the head.\nNode curr = head;\nwhile(curr != null)\n{\n    System.out.print(curr.getData() + “ “);\n                                //This could be any process that you want to do\n                                //with each node.\n\n    curr = curr.getLink();\n                                //AND then you have to move curr to the next \n                                //node using curr's link.\n}\nSystem.out.println();           //Any process to be done after traversing the \n                                //list"
  },
  {
    "objectID": "lesson3.html#inserting-items-into-the-list",
    "href": "lesson3.html#inserting-items-into-the-list",
    "title": "Linked Lists",
    "section": "2.3 Inserting items into the list",
    "text": "2.3 Inserting items into the list\nSo far we’ve seen how to add nodes to the end of the list. That process involves creating the node and storing its address in the link section of the last node in the list.\nAdding a node to the middle of the list is slightly different because we have to maintain the integrity of the list on both sides of the node that we are inserting.\nWe shall look at the lines of code to insert a node after curr and how it looks diagrammatically.\n\n\n\n\n\n\n\n\nCode\nDiagram\n\n\n\n\nNode newNode = new Node();     newNode.setData(72);\n\n\n\nNewNode.setLink(curr.getLink());\n\n\n\ncurr.setLink(newNode);\n\n\n\n//which is technically the       //same as this diagram.\n\n\n\n\n\nThe order in those statements is very important. We make our new node point to the next node in the linked list, and the make the curr node point to our new node.\nLet us see what happens when we reverse that order.\n\n\n\n\n\n\n\n\nWrong Code\nError Diagram\n\n\n\n\nNode newNode = new Node();     newNode.setData(72);\n\n\n\ncurr.setLink(newNode);\n\n\n\nnewNode.setLink(curr.getLink());\n\n\n\n//which is technically the       //same as this diagram.\n\n\n\n\n\nNotice that when I reverse the order of the lines of code (as shown above), I add the node in the right place BUT I lose access to the tail end of the list.\nAnother way we can correctly add a node to list is by using two separate node references.\n\n\n\n\n\n\n\n\nCode\nDiagram\n\n\n\n\nNode p, q;          //assuming they are          //both properly initialized         //and positioned.\n\n\n\nNode newNode = new Node();     newNode.setData(77);\n\n\n\n//Now the order of      //operation doesn't matter     //as much     p.setLink(newNode);     newNode.setLink(q);\n\n\n\n//it produces the same      //results if the order is      //changed.     newNode.setLink(q);     p.setLink(newNode);"
  },
  {
    "objectID": "lesson3.html#deleting-items-from-the-list",
    "href": "lesson3.html#deleting-items-from-the-list",
    "title": "Linked Lists",
    "section": "2.4 Deleting items from the list",
    "text": "2.4 Deleting items from the list\nWhat about if we wanted to delete an item from the list. If the node we want to delete is the node after curr, we make curr point directly to the node that was pointed to by the node pointed to by curr. It sounds confusing but its really easy. If a pointed to b which pointed to c, we now just make a point to c. The code should make it clearer.\n\n\n\n\n\n\n\n\nCode\nDiagram\n\n\n\n\n//assuming this is what the list looks like and we want to delete the node with 56.\n\n\n\ncurr.setLink(curr.getLink().getLink());\n\n\n\n\n\nNotice that the node with 56 is essentially deleted since there is no way to traverse to it. However, that memory still has information and is inaccessible to us i.e. the node is dangling. Java will eventually get rid of this using its garbage collection feature.\n\n\n\n\n\n\nWrite some java code to demonstrate all the above?"
  },
  {
    "objectID": "lesson3.html#building-forward",
    "href": "lesson3.html#building-forward",
    "title": "Linked Lists",
    "section": "3.1 Building forward",
    "text": "3.1 Building forward\nWe will need three pointers to build the list: one to point to the first (or head) which should not be moved, one to point to the last (or tail) node in the list, and one to create the new node. In this example, we’ll call them first, last, and curr respectively.\nNode first, last, curr;\nint num;\n…\nfirst = null;           //initially the list is empty and so we have to\nlast = null;            //appropriately initialize first and last.\n…\ncurr = new Node();      //create a new node\ncurr.setData(12);       //store that input in the data portion of the node\n…\n//Now to add any kind of node to the list, we have to check to see whether the \n//list is empty or not. If it is empty, we have to change both first and last,\n//Otherwise, we only have to change last.\n\nif(first == null)\n{\n    first = curr;       //If it is empty, we have to change both first and last\n    last = curr;        //to point to the new and only node in our list\n}\nelse\n{\n    last.setLink(curr); //Otherwise, we have to change the old last to point\n    last = curr;        //to the new node, and change last to point to the\n}                       //new last node.\nThe code above can be put into a loop to create the list in the forward direction. The **last* pointer allows us to insert the new node in the proper position without having to traverse the list for every node insertion. Without it, we would have to traverse the list from beginning to the end before inserting the node. It should be obvious that this becomes very inefficient as the size of the list grows."
  },
  {
    "objectID": "lesson3.html#building-backward",
    "href": "lesson3.html#building-backward",
    "title": "Linked Lists",
    "section": "3.2 Building backward",
    "text": "3.2 Building backward\nWhen building backward, we insert the new node at the beginning of the list. We therefore do not need to have last BUT we’ll need first. BTW, It will always keep changing with each insertion.\nNode first, curr;\nint num;\n…\nfirst = null;\n…\ncurr = new Node();\ncurr.setData(10);\ncurr.setLink(null);\n…\ncurr.setLink(first);   //make the new node point to the old first\nfirst = curr;         //Then change first to point to the new node."
  },
  {
    "objectID": "lesson3.html#doubly-linked-lists",
    "href": "lesson3.html#doubly-linked-lists",
    "title": "Linked Lists",
    "section": "5.1 Doubly linked lists",
    "text": "5.1 Doubly linked lists\nYes it’s a thing. Every node has two links instead of the more traditional one link. One of the links points to the next node, and the other link points to the previous node. Every node (except the last) will contain the location of the next node, and every node (except the first) will contain the location of the previous node. This allows us to traverse the list forward or backward using head, tail and the links.\n\nWith doubly linked lists, insertion and deletion typically require the modification of two nodes i.e. the preceding and proceeding nodes.\nclass Node\n{\n    int data;\n    Node next;\n    Node back;\n\n    // accessors, mutators, and constructor missing.\n}"
  },
  {
    "objectID": "lesson3.html#circular-linked-lists",
    "href": "lesson3.html#circular-linked-lists",
    "title": "Linked Lists",
    "section": "5.2 Circular linked lists",
    "text": "5.2 Circular linked lists\nIn this kind of linked list, the last node points to the first node. With circular linked lists, it is convenient to make first point to the last node of the list. That way, you have access to both the last and first (using first.getLink()) nodes with a single variable."
  },
  {
    "objectID": "lesson1.html",
    "href": "lesson1.html",
    "title": "Introduction to Data Structures & Complexity",
    "section": "",
    "text": "A data structure is a way of storing data in a computer so that it can be used efficiently. In your programming experience so far, you have used some data structures but may not have known that they were data structures. An array is an example of a data structure. The elements are arranged in contiguous memory locations so that they can be accessed, stored, and manipulated quickly. Other types of data structures include sets, unions, records, graphs, trees, etc. Do not confuse data types and data structures. Think of data types as atoms and data structures as molecules. Examples of data types are int, short, long, float, double, char, boolean, etc. So we’ve said that we store data in data structures so that it can be manipulated efficiently, but what exactly does that mean? Manipulation usually means searching, sorting, changing, etc. We normally process some form of input efficiently to generate the “right” output. Data structures allow us to store this data in a way that makes the processing better.\nData structures is essentially what this class is about (as I have mentioned before on many occasions). We will spend the rest of this quarter looking at different commonly used data structures and how we can use them in our code.\n\n1 Complexity\nComputer Scientists are weird people. Whereas the rest of the world is looking at the best times as a measure of effectiveness and excellence, we are looking at the worst time. Usain bolt is celebrated as a runner because he run 100m in 9.58s. In fact, every four years, the whole world stops to watch and celebrate different people demonstrate the best of the best when it comes to physical feats. In computer science, we are more interested in the worst case. This is partly because knowing the worst case allows us to give hard guarantees in our estimates, and prepare for deadlines. After all, the saying is “hope for the best, prepare for the worst.”\nTo represent this “worst case” we use what is referred to as a big-O notation as a measure of how well or poor an algorithm is. This might seem counter intuitive since run time seems the natural unit to measure the performance of an algorithm. However, while run time is a very accurate time measure, it is a very inaccurate algorithm comparison measure. This is because A LOT of factors affect the runtime of an algorithm and many of them have nothing to do with the algorithm itself which is what we are interested in.\nFor example, if I gave you a program to sort some numbers and after executing it, you determined that it took 5 seconds to run. That 5 seconds cannot tell you whether it is better than another sorting program that your colleague executed in 8 seconds. Why? How much of that 5 seconds run time is down to the computer system one is using (faster processor)? Or the programming language that it was coded in? Or the skill level of the programmer? Or the specific state of the list that was to be sorted (since it might take a short time for a list that was already sorted)? Or the size of the list that was sorted? Almost all these factors that affect the runtime have nothing to do with the “goodness” or “badness” of the actual algorithm which is what we are interested in in order to compare it with another algorithm.\nBig-O is the computer scientist’s answer to all these problems. It is inexact by design and it is this feature that typically confuses people who are looking at big-O for the first time. In a bid to ignore all the non- factors we mentioned earlier, big-O describes the performance of an algorithm in terms of a variable (typically n) that represents the size of the problem. In fact, the big-O notation shows how dependent the algorithms runtime would be on the size of the input data. This data could be anything from the size of a string, to the size of an array, to the size of the problem space, to the number of guests, to the number of slices of pizza. This allows us to shed the fine details and divide problems into categories or broad classes based entirely on how they perform as the size of the data is increased.\n\n\n2 Dinner Party\nAs an example, let us consider this scenario [1]. You are preparing to host a dinner party and this task involves a lot of algorithms which we shall discuss and then categorize using their big-O notation (i.e. how they perform as the data size increases).\nThe first task on your to-do list is cleaning your house. This task does not depend on the number of guests that we are inviting to the dinner party (n). It could take either 3 days or 3 hours (depending on the size of your house) but this is of no consequence to a computer scientist. Since this problem does not change its runtime when the number of guests changes, it is referred to as a constant time problem or \\(O(1)\\).Notice that the variable n does not appear in the parentheses because its run time does not depend on n.\nWhen your guests are at the table, another task on your to-do list is to pass the plate of hors d’oeuvres (its a fancy dinner party) around the table. Clearly the amount of time that this task will take will depend directly on the number of guests at the party. If its just 3 people, it should take about half the amount of time as if it was 6 people. And a dinner party of 300 people would take 100 times as long as the 3. This kind of problem is referred to as a linear problem or \\(O(n)\\). Because big-O is inexact, we don’t care about any multiplicative factors. In the context of this example, we don’t care whether the dish has to be passed round twice or once. To big-O, these are both the same i.e. linear because whether you pass the dish around once or twice, the runtime will grow linearly with the number of guests you invite.\nIn fact, adding a constant subtask does not change its big-O. Making an announcement (which is O(1)) before passing round the hors d’oeuvres (O(n)) still remains O(n) because the runtime for the combined task will still be linear with respect to the number of guests invited. Making an announcement and then passing the dish around a table of 10 will still be about half as short as making an announcement and then passing the dish around a table of 20. This ignoring of less important factors is particularly difficult to wrap your mind around when the constant time factor is a big factor. For example, remodeling your kitchen (O(1)) and then passing the dish around is still in the same category as just passing the dish around even though the first one will take significantly longer. They are in the same category because as the size of the data increases (n), they respond in the same way i.e. linearly.\nAnother task could be having every guest hug each other when they arrive. If there are just two guests, only one hug would be required. With 10 guests, 45 hugs would be required. With 50 guests, 1225 hugs. With 100 guests, 4950 guests. It is easy to tell that the runtime of this problem grows at a faster rate than the size of the problem i.e. the number of hugs becomes larger at a faster rate than that at which the number of guests grows. In fact, this problem falls in the polynomial category; more specifically the quadratic kind \\(O(n^2)\\). This means that if the nput data size doubles, the runtime will increase by a factor of 4. Again any multiplicative or smaller factors don’t matter in big-O. For example, if your task involved everyone hugging each other, then passing a dish around the table, as well as a speech at the beginning of the dinner, the whole task would be \\(O(n^2)\\) because of all the subtasks, it is the \\(O(n^2)\\) factor that will dominate the runtime of the algorithm (i.e. it is the task that will grow most significantly as the input data size increases). Recall that big-O is inexact. We are only trying to capture an expression that represents how its runtime will grow with an increasing data size. Imagine that your dinner guests got involved in a game that required you to stand them in order of height for a game. The sorting algorithms you are familiar with from the Living With Cyber series (e.g. bubble sort) would fall into the O(n2) family. Sorting a group of 100 people will take 100 times as long as sorting a group of 10 people even if the size of the group has only increased by a factor of 10.\nSuppose that as dinner host, your roles involve having short conversations with not just everyone individually, but every possible grouping of your guests. For example with 3 guests, A, B and C. You have to have a conversation with A, B, C, AB, AC, BC, and ABC (i.e. 7 conversations). You don’t need to be an introvert to be daunted by such a task because it grows even faster than the quadratic category discussed earlier. With 4 guests (ABCD), you would need to have 15 conversations i.e. A, B, C, D, AB, AC, AD, BC, BD, CD, ABC, ABD, ACD, BCD, and ABCD. Notice how adding a single guest has basically doubled the amount of work you have to do. It would require 31 conversations for 5 guests, and 63 for 6 guests. This category of problems is exponential or \\(O(2^n)\\), and algorithms in this category are typically avoided because their runtimes get very ugly even for relatively small data sizes. You might recall that we discussed the towers of Hanoi in the Living with Cyber series. The best solution to Towers of Hanoi falls in this category.\nOne other task as dinner host could be deciding how to seat all your guests. Perhaps your guests are very particular about how they should be seated, who they seat next to, etc. Figuring out a seating arrangement even with basic limitations might involve enumerating all the different seating possibilities, and then ranking them and choosing the best. For example, with three guests (ABC), they could be sat as ABC, ACB, BAC, BCA, CBA or CAB. This means that with just 3 guests, I have to write out and compare 6 different seating arrangements. With 4 guests (ABCD), they could be arranged as ‘ABCD’, ‘ABDC’, ‘ACBD’, ‘ACDB’, ‘ADBC’, ‘ADCB’, ‘BACD’, ‘BADC’, ‘BCAD’, ‘BCDA’, ‘BDAC’, ‘BDCA’, ‘CABD’, ‘CADB’, ‘CBAD’, ‘CBDA’, ‘CDAB’, ‘CDBA’, ‘DABC’, ‘DACB’, ‘DBAC’, ‘DBCA’, ‘DCAB’, or ‘DCBA’ for a grand total of 24 arrangements. This category is perhaps the worst of the worst and is referred to as factorial or \\(O(n!)\\). This explains why making seating arrangements at weddings is a very stressful and time intensive venture.\nOne last task. Supposed that in the game we mentioned earlier (where your guests are standing in order of height), you have a task of figuring out whom among your guests has a specific height (which is given in units you are unfamiliar with but which your guests are comfortable with). A quick approach (which should also be familiar to you) would be to go to the middle of the line, and ask that guest if he/ she is the height you’re looking for. It should also be easy to determine whether he/she is taller or shorter than the required height, and as a result you will discard half your guest list from possible suspects. This is similar to the binary search algorithm that you are familiar with. As discussed in Living with Cyber, this algorithm belongs in the logarithmic category or \\(O(log_2n)\\). Algorithms in this category typically reduce the size of the data at each step (by half in this case).\nThere is another major category called the quasi-linear / linearithmic or \\(O(nlog_2n)\\). It doesn’t grow as fast as O(n2) but is faster than O(n). There are a few sorting algorithms that fall into this category that we will be discussing later in the course.\nBroadly speaking, those are the main big-O categories. Once you understand them, you should be able to look at different algorithms and determine which group or family they belong to. Sometimes this involves looking at the algorithm itself, and other times it involves looking at a mathematical expression for its runtime, \\(T(n)\\) given in terms of its data size, \\(n\\). Can you describe the order of growth from these functions using the big-O notation?\n\\[n^3 +2n\\] \\[2n^3 + n^2\\] \\[n+2nlog(n)\\] \\[3n +2n^7\\] \\[n(n+3)/2\\] \\[6\\] \\[1+n^2 +2n^3+3n^4+2^n\\] \\[n^3+2n log(n)\\]\n\n\n\n\n\n\nNote\n\n\n\nRemember the trick is to pick the dominant term and ignore the constants. Basically which term will get out of hand as n increases to really large values?\n\n\n\n\n3 Starting with the algorithm\nKeeping with food, let’s look at a few algorithms you must have used at some point in your lives [2].\npublic donut takeDonut(donut [] box)\n{\n    return box[0]; //return the donut in the first position of donut box\n}\nWhat complexity do you think the algorithm above demonstrates? Does it depend on the number of donuts in the box?\npublic void eatFries(fries [] box)\n{\n    for(int i = 0; i &lt; box.length; i++)\n    {\n        //dip chip in ketchup\n        //eat fry\n    }\n}\nWhat about the complexity of the algorithm above? What kind of relationship is there between its runtime and the number of fries in the box?\n// Every guest comes with a different kind of food   to a potluck i.e. number\n// of guests is the same as the types of food\n\npublic void divideFood(ArrayList&lt;Food&gt;potluck)\n{\n    // for each dish in the potluck\n    for (Food dish : potluck)\n    {\n        // divide food into proper portion sizes based on guest list size.\n        for (int j = 0; j &lt; potluck.size(); j++)\n        {\n            // cut up the food\n        }\n    }\n}\nWhat about the algorithm above? Cutting up the food grows as the amount of food in the potluck grows? Does it grow in a linear fashion or not? Play through the scenario in your head to see if you can recognize the pattern. Two people, everything is cut into two pieces (for a total of 4 portions). Three people, everything is cut into three pieces (for a total of 9 portions). Four people, four pieces each (16 total portions).\nFor simple algorithms, you might be able to simply look at the algorithm and determine what its complexity is. However, more often that not you will need to carry out what is referred to as a Time analysis. It involves identifying the parts of the algorithm where repetition is carried out (since repetition is the main factor that would affect runtime especially as the input size increases) and then writing out a mathematical expression (T(n)) that describes how long a basic statement in that loop would be executed. Once the T(n) expression has been completed, determining the O() is just a matter of identifying the most dominant term in the expression and ignoring any constants. Let’s look at a few examples of code and see if we can deduce their complexities.\nfor (int k=0; k&lt;n; k++)\n{\n    ...      // How many times will this statement be executed?\n}\nAny line in the \\(for\\) loop above will be executed n times. Therefore \\(T(n) = c*n\\) and its complexity is O(n). The constant term c is a multiplier we use to define how long the statements in the loop would take to execute in a single iteration. What about the one below.\nfor (int k=0; k&lt;n; k++)\n{\n    ...     // How many times will this statement be executed?\n    for (int j=0; j&lt;n; j++)\n    {\n        ...    //What about this statement?\n    }\n}\n\\(T(n) = cn^2 + dn\\) which means it is \\(O(n^2)\\).\nThose were fairly straight forward. What about these ones?\nfor (k=0; k&lt;n/2; k++)\n{ \n    ...  // This statement occurs n/2 times\n    for (j=0; j&lt;n*n; j++)\n    {\n        ...  //This statement occurs n*n*n/2 = n^3/2 times\n    }\n}\n\\(T(n) = (cn^3 +dn)/2\\) which means it is \\(O(n^3)\\).\nfor (k=0; k&lt;n/2; k++)\n{\n    ...  // This statement occurs n/2 times\n}\nfor (j=0; j&lt;n*n; j++)\n{\n    ...  //This statement occurs n*n = n^2 times\n}\n\\(T(n) = cn^2 +(dn)/2\\) which means it is \\(O(n^2)\\).\nk = n;\nwhile (k &gt; 1)\n{\n    ...\n    k /= 2;  //integer division - log2n\n}\n\\(T(n) = c*log_2n\\) which means it is \\(O(log_2n)\\).\n\\(log_2n\\) implies division by 2.\n\\(log_3n\\) implies division by 3.\n\\(log_4n\\) implies division by 4…and so on.\n\n\nSometimes calculating the actual number of steps from the T(n) expression will give you an idea of what the dominant term is based on how fast it grows with an increasing n. For example, suppose the time T (number of steps) it takes for a hypothetical algorithm to complete a problem of size n is given by the expression \\[T(n) = 4n^2 – 2n + 2\\] Then we know that if our size is 1, it will take \\[T(1) = 4 – 2 + 2 = 4 steps\\] If our size is 10, it will take \\[T(10) = (4 * 10^2) – (2 * 10) + 2 = 382 steps\\] If our size is 100, it will take \\[T(100) = (4 * 100^2) – (2 * 100) + 2 = 39802 steps\\] and if our size is 1000, it will take \\[T(1000) = (4 * 1000^2) – (2 * 1000) + 2 = 3999802 steps\\]\nYou will have noticed that while our input was only increasing by a factor of 10, the number of steps was increasing by a factor of 100…ish. This is because the dominant term of T(n) is \\(n^2\\) and so we can describe the complexity of this hypothetical algorithm as being \\(O(n^2)\\).\nOnce we have the big-O notation, it can then be used to provide an estimate (admittedly a very poor estimate) of the amount of time (or number of steps) that an algorithm would require for a given data size and then compare it with other algorithms without actually taking the time to implement either algorithm in code. For example given \\(O(n^2)\\) where n is 1000, the algorithm would take approximately: \\[O(1000) ≈ 1000^2 = 1000000 steps\\]\nThe number of steps can then later be translated to time if you know how long the average step would take on a specific system.\nBelow is a table showing the most common big-O categories and some common examples of algorithms in those categories [3].\n\n\n\n\n\n\n\n\nBig-O\nName\nExamples\n\n\n\n\n\\(O(1)\\)\nconstant\n\nAccessing an element in an array given its index e.g. Getting the first element of a list\nChecking if a number is even or odd\n\n\n\n\\(O(logn)\\)\nlogarithmic\n\ncures scurvy\ntasty\n\n\n\n\\(O(n)\\)\nlinear\n\nLinear search eg.finding the maximum element in a list\n\n\n\n\\(O(nlogn)\\)\nquasi-linear\n\nAdvanced sorting algorithms e.g. mergesort\n\n\n\n\\(O(n^2)\\)\nQuadratic\n\nBasic sorting algorithms e.g. bubblesort\nSearching for duplicates in a list*\nDealing with a two dimensional array\n\n\n\n\\(O(n^3)\\)\nCubic\n\nDealing with a three dimensional array\nSolving a three variable equation\n\n\n\n\\(O(2^n)\\)\nExponential\n\nFinding all subsets of a data collection\nTowers of Hanoi\n\n\n\n\\(O(n!)\\)\nFactorial\n\nFinding all permutations of a given data collection e.g. figuring out a password given all the characters of the password.\n\n\n\n\nJust a few last tips on identifying the dominant term from an expression.\n\nn dominates \\(log_bn\\) (b is often 2)\n\n\\(nlog_bn\\) dominates n\n\\(n^m\\) dominates \\(n^k\\) when m&gt;k\n\\(a^n\\) dominates \\(n^m\\) for any values of a and m greater than 1.\n\n  Ref: Algorithms to Live By, by Brian Christian and Tom Griffiths https://vickylai.com/verbose/a-coffee-break-introduction-to-time-complexity-of-algorithms/ https://adrianmejia.com/blog/2018/04/05/most-popular-algorithms-time-complexity-every-programmer-should-know-free-online-tutorial-course/ Object Oriented Data Structures using Java (4th Edition). Nell Dale, Daniel T. Joyce, Chip Weems."
  },
  {
    "objectID": "lesson0_2.html",
    "href": "lesson0_2.html",
    "title": "Behind the Scenes in Java",
    "section": "",
    "text": "If the discussion in this section is a bit too difficult for you to understand, please refer to the last Computer Architecture discussion we had in CSC132. Recall that during our discussion of how a computer works, we talked about the makeup of memory. At a very basic level, memory is made up of “words” which is a unit of memory. Each word has a specific address, and is used to store both data and the instructions that work upon that data. The diagram below shows a sample memory space with 256 words."
  },
  {
    "objectID": "lesson0_2.html#memory",
    "href": "lesson0_2.html#memory",
    "title": "Behind the Scenes in Java",
    "section": "",
    "text": "If the discussion in this section is a bit too difficult for you to understand, please refer to the last Computer Architecture discussion we had in CSC132. Recall that during our discussion of how a computer works, we talked about the makeup of memory. At a very basic level, memory is made up of “words” which is a unit of memory. Each word has a specific address, and is used to store both data and the instructions that work upon that data. The diagram below shows a sample memory space with 256 words."
  },
  {
    "objectID": "lesson0_2.html#storing-variables",
    "href": "lesson0_2.html#storing-variables",
    "title": "Behind the Scenes in Java",
    "section": "2 Storing variables",
    "text": "2 Storing variables\nThe operating system is in charge of mapping variables to addresses and the data stored in that address and there are two main ways that it does this.\nWith direct addressing , the location associated with the variable stores the value of that variable. This is typically the case with primitive data types e.g. characters, int, float, long, etc. The variable is said to be stored by value.\nWith indirect addressing, the location associated with the variable stores the address of another location that has the actual value. Think of it as the memory location is storing the keys of the actual place where the value is stored. This is typically the case with complex data types e.g. strings, objects created from classes, etc. The variable is said to be stored by reference.\n\nchar ch = ‘a’; //direct addressing    \nString str = “dog”;     \n\n/*\nindirect addressing. str has the address 03 and the actual value is found at that address. \nThis consists of the data plus some extra information that could help with some extra manipulation.   \n    \nThis is sometimes represented as    \n\n                str -&gt; dog  \n    \n**spoiler alert: This arrow representation will come back later when we discuss linked lists.*/"
  },
  {
    "objectID": "lesson0_2.html#what-does-this-mean-for-our-programming",
    "href": "lesson0_2.html#what-does-this-mean-for-our-programming",
    "title": "Behind the Scenes in Java",
    "section": "3 What does this mean for our programming?",
    "text": "3 What does this mean for our programming?\n\n3.1 Creating objects\n// This is a basic class representing a circle All it stores is the radius. \n// It has a constructor, an accessor and a mutator.\nclass Circle\n{\n    private int radius;\n\n    public Circle(int radius)\n    {\n        setRadius(radius);\n    }\n\n    public void setRadius(int radius)\n    {\n        if (radius&gt;=0)\n            this.radius = radius;\n        else\n            this.radius =1;\n    }\n\n    public int getRadius()\n    {\n        return this.radius;\n    }\n    \n    public String toString()\n    {\n        return \"This circle has a radius of \" + this.getRadius();\n    }\n}\nGiven the Circle class defined above, let’s write some lines of code and see what happens in memory, and how it can be represented diagramatically. We shall also be manipulating a primitive type (int) so that you can notice the contrast between the two.\n// Simple declaration of two variables. \n// One is an object of type Circle and the other is a primitive integer\nCircle a; \nint x;  \n\nNotice that without any initialization, Java will put some default values in those memory locations. For objects, the default value is null to mean the lack of a reference (or address). The default value for ints is 0.\nFYI null can also be used in object comparison\nif (a== null)\n    System.out.println(“Circle has not been initialized”);\n// Assigning initial values to both a and x. \n// For a, this involves creating a circle object and passing it any required  parameters.\n\na = new Circle(5); \nx = 5; \n\nWhile the location associated with x stores the actual value of x (i.e. 5), the location associated with a stores the address of a location in memory (12AB) where the information representing the circle object is actually stored. This means x is stored by value, and a is stored by reference. Declaration and Initialization can also be done in a single step.\nCircle b = new Circle(7);\nint y = 7;\n\nBoth a and b are objects and therefore are stored by reference while x and y which are primitive types are stored by value.\n\n\n3.2 Assigning objects\nWhen a primitive type is assigned, the value stored in the location is copied to the new location.\nx = y;      // This copies the value that was in y into x.\na = b;      // This copies the reference stored in b into a\nHowever, when an object is assigned, whatever is stored in the source location is copied into the target location. Recall that an address/reference is actually what is stored and not the actual value. Therefore object assignment has the unique effect of making both variables refer to the same copy of the object instead of having two copies of the object.\n\nThere are a couple of implications of this behavior.\n\nFirstly, the original circle located at 12AB is no longer accessible. The memory location is being used to store the circle, but that circle can no longer be used since there is no way to get to it. The space it takes up is now referred to as garbage. Java automatically cleans garbage(garbage collection) so that the computer/program has access to that memory eventually. This is not the case in other languages.\n\nCircle c;\nfor (int n = 0; n &lt; 100; n++)\n{\n    c = new Circle(n*2); // create a circle with a radius twice the size of n\n}\n/* Notice that when this loop finishes execution, you will only have access to the last\ncreated circle and not the 99 circles before that (which now constitute garbage) */\n\nSecondly, and perhaps more importantly, since a and b refer to the exact same circle (there are two keys to the same house), then any changes made to the copy a (whether intentional or accidental) also affect the original b.\n\n\n\n3.3 Objects as parameters to functions/methods\nThat last point we discussed might seem very small and avoidable but in reality it isn’t. That’s because whenever an object is passed as a parameter in a function, it is passed by reference. So even if it might have another variable name in the function, any changes to the object will affect the original object.\nclass Test\n{\n    public static void main(String [] args)\n    {\n        Circle a, b, c;\n        a = new Circle(3);\n        b = new Circle(5);\n        c = combinedCircle(a, b);\n        System.out.println(a); // a will have a radius of 10 because it was changed\n        System.out.println(b); // “unintentionally” in the combinedCircle function.\n        System.out.println(c);\n        }\n    public static Circle combinedCircle ( Circle x, Circle y)\n    {\n        Circle z = new Circle(x.getRadius() + y.getRadius());\n        x.setRadius(10);      // statement that changes one of the input arguments, and \n                              // inadvertently changes the original copy in the process.\n        return z;\n    }\n}\n\n\n3.4 Arrays\nWe have mentioned how primitive types are stored and passed (i.e. by value) and how objects are stored and passed (i.e. by reference). But what about arrays? Recall that with primitive types, the variable name is mapped directly to a memory location that contains the value associated with that variable (by value). Conversely, with objects, the variable name is mapped to a memory location that contains the address of another place in memory where the object state is being stored (by reference). Arrays (of any type) are treated like objects. That means that the array name is mapped to a memory location that contains the address of the first of a block of memory locations that contain the array elements i.e. arrays are passed by reference. This means that if you pass an array as an argument to a function, that function is in fact dealing with the original array and therefore any changes to the array will last even after control has been passed back to the original function.\nimport java.util.*\nclass Trial\n{\n    public static void main(String [] args)\n    {\n        Random r = new Random();\n        int [] arr = new int [100]; // create an array of 100 integers (by default all set to 0)\n        for (int i = 0; i &lt; arr.length; i++)\n        arr[i] = r.nextInt(1000);   // random integer from 0-1000\n        // Sort the array\n        selectionSort(arr); // Note that this function only takes an argument and does not return\n                            // any values. Nonetheless, it is capable of making changes to the \n                            // original array since it has the reference to that array.\n        // Print out the array\n        for (int i = 0; i &lt; arr.length; i++)\n        System.out.print(arr[i] + “ “);\n    }\n    public static void selectionSort(int [] list)\n    {\n        // a sort function that doesn’t have a return type (i.e. void) but actually affects the \n        // variable in the original function. So in an essence it does return something\n    }\n}\nNotice in the example above how the selectionSort function doesn’t have a return type but is still able to affect a variable in the original main function.\n\n\n3.5 Arrays of Objects\nOccasionally, it is necessary to create an array of objects. If objects are mapped by reference, and arrays are mapped by reference, then what about arrays of objects?\nint [] arr = new int [10]; // an array of primitives (for comparison)\nCircle [] circles = new Circle [10];  // an array of circle objects which by default are all set\n                                     // null. Any of the circle elements can now be initialized.\ncircles[0] = new Circle(5);\ncircles[4] = new Circle(8);\nThe variable name of the array will store the first address of a block of memory cells that have been set aside to store addresses for the objects. Think of it as circles is storing a key, and that key opens a chest of drawers each of which has another key to a circle in another location. Incidentally, this idea of a variable name storing a reference to an array of references is the same way a multidimensional array is dealt with.\nint [][] arr = new int [4][10];       // a 2D array of 4 rows and 10 columns.\narr[2][8] = 103;                     // store the value 103 in the 3rd row and 9th column.\nIn the example above, arr is storing a key. That key opens up a row of drawers. In each of those drawers is another key that opens up a row of drawers where the values are actually kept. In more official terms, arr is a reference to a single dimensional array that contains references. Each of those references gives access to their own single dimensional array of values. So a 2D array is an array of arrays.\n\n\nReferences:\nObject Oriented Data Structures using Java (4th Edition). Nell Dale, Daniel T. Joyce, Chip Weems."
  },
  {
    "objectID": "lesson0_1.html",
    "href": "lesson0_1.html",
    "title": "Introduction",
    "section": "",
    "text": "To be in this CSC 220 class, you must have passed the Living With Cyber series taught in CSC 130-132. In that series, you covered the breadth of computer science and learned how to program using Python. At the tail end of CSC 132, you must have also covered some programming in Java. Granted, it might not have been a lot of hands on and you might not be completely comfortable with it, but this class is based on the assumption that you know what it is, and can write some programs using java. Another thing worth mentioning is that this class is a data structures class and NOT a learning how to code in java class. As such the material we’ll cover in class will be mainly about the data structures. However, by the end of the class, you will be expected to be comfortable in programming in Java. In order to bridge this gap, you will have to put in a LOT of extra hours just practicing and learning java on your own. We will spend a few classes at the beginning of the course to cover some of the more unique aspects of java, but the bulk of programming in java is going to be up to you on your own free time. The longer you take to tackle this task, the more detrimental to your assignments this will be. The assignments in this class are more involved and complex than the ones you saw in the Living With Cyber series and will be challenging even for someone who is comfortable with Java. Therefore, take a good amount of time at the beginning of the quarter (first couple of weeks) to get really comfortable with java and the command-line because the assignments will come thick and fast, and you don’t want to get bogged down with java issues when you are trying to solve data structure issues.\nI hope that you are now comfortably scared motivated. Here is a link that you can use to get comfortable with Java. https://runestone.academy/ns/books/published/java4python/Java4Python/toctree.html\nIt is written for a student that is comfortable with python and so I think it will be really useful for you to read through it a couple of times. It shouldn’t take you more than a couple of hours for each read through. Additionally, practice some basic programming in java by attempting some of the assignments you did in Living With Cyber but using java as your language.\n\n\nUsing the terminal can look daunting at first glance but it isn’t as bad as it looks. Unfortunately, like most practical skills one will need to practice using it over and over again before they can become good at using it. The benefits are numerous and being comfortable with the terminal will set you apart from your competition in the work place and in class. After all, every tom, dick, and harry can use an IDE. One of the benefits of using terminal is that combining your code with pre-existing scripts and commands is so easy and allows you to use any terminal or bash tools that are already in existance instead of writing new scripts for the same job. This is particularly important when redirecting input and output from java code which is something you are going to have to do over and over again in this class. The earlier you get comfortable with it, the better for you.\nOther than redirecting output, there are multiple things one can do with terminal and/or bash. https://goo.gl/YzMeBm\nThe link above is to a series of short (a couple of minutes each) tutorials on easy bash tasks that you can learn to do on terminal. They don’t have any direct impact on your java programming but I would highly encourage that you at least take a look at the first few videos and see what I am talking about when I say that you will want to be good at using terminal…and it will take repetition and time. Once you get comfortable with it, you will find that it will be considerably faster than your usual point and click techniques that you are used to and any time you spent watching this videos and trying out some of those commands will be time well spent…trust me. Once you have the latest java jdk installed on your machine, you will have to make sure that it can be compiled and executed from the command line. This is particularly involved with windows machines. Compiling and executing a java file should be automatic with linux machines. Keep track of where (which folder) you installed java on your window system since you will need that information later. Particularly the bin folder. Typically it will be located at  C:\\Program Files\\Java\\jdk1.8.0_31\\bin  This might look different for your own windows computer and so make sure you can find it. You will then need to edit your path variable (under SYSTEM VARIABLES) and add your folder location to it. If done properly, the commands java and javac should return some intelligible information when typed into the terminal. https://goo.gl/dxHUkg\n\n\n\nJava is a formal programming language and one of the most common in use today. Because of that, it is almost impossible to have a career in some form of programming and not use java. It is faster than python (particularly for larger programs) and a lot of the security features it possesses allow you to write programs that will crash less often when run. It is also easy to be used by more than one programmer when a team is working on a project together.\n\n\n\nclass Trial\n{\n   public static void main(String [] args)\n   {\n      System.out.println(“Hello World!”);\n   }\n}\n The code above is the java version of the famous hello world program. Before we get bogged down with the differences between java and python, we shall run this program (using terminal). You might recall that java is an interpreted language. This means that running ajava program is a two step process i.e. compiling and execution. Compiling allows the computer to convert the java program into a form that is easy to distribute and execute on multiple systems. It also allows the computer to quickly identify potential errors and bring them to your attention before you execute the program. Contrast this with Python which is a scripted language and therefore has to be distributed as the source file. Additionally many of the errors could only be identified during the program execution which one could argue it too late for errors to be found. To compile, navigate to the folder/directory in which the .java file is, and then run the command:  javac filename.java  If there aren’t any syntax errors, then the command above should NOT return any message or output. It should however create a file (Trial.class) whose name depends on the names of the classes in the java files. To execute the program, run the command:  java Trial  This should produce the appropriate/expected output to the terminal. If your java program contained multiple classes, then the compilation would produce multiple class files. To execute your program, you would run the command above using whichever class file contained the “main program.” So now let’s discuss the actual program. Even with something as small as this program, you should be able to notice a few differences from python. First off, everything in Java is in a class. There can’t be a statement, function, etc. that is not in a class. So even for a simple hello world, we have to make a class. Classes, functions, and code blocks in general are delineated by curly braces. They show where the code blocks start and end. In python, such blocks were marked by a uniform indentation. While indentation is HIGHLY encouraged in Java, it is not strictly enforced. Statements in java are ended using a semi-colon. Consider it the full stop or period of the java programming language. Without it, the compiler will assume that the next statement is just a continuation even if there are multiple spaces and or lines between them. The reason for this is that it is common in java to have statements that span multiple lines while that was very infrequent in python.Statements that you want to be executed should be put into functions/methods.You can have any number of functions in the class but there must be a main function. This function can be compared to the conductor of an orchestra. It is the function that the compiler will begin and end its execution with. The main function is in charge of determining which other functions will be executed if any at all. Interestingly, it doesn’t have to be at the top of the class but it being at the top of the class might help with readability of your code. The main program has a specific signature or name i.e.\npublic static void main(String [] args)\n\n\n\n\n\n\nNote\n\n\n\nMemorize it because you will be writing it for every single Java program you write."
  },
  {
    "objectID": "lesson0_1.html#using-the-terminal",
    "href": "lesson0_1.html#using-the-terminal",
    "title": "Introduction",
    "section": "",
    "text": "Using the terminal can look daunting at first glance but it isn’t as bad as it looks. Unfortunately, like most practical skills one will need to practice using it over and over again before they can become good at using it. The benefits are numerous and being comfortable with the terminal will set you apart from your competition in the work place and in class. After all, every tom, dick, and harry can use an IDE. One of the benefits of using terminal is that combining your code with pre-existing scripts and commands is so easy and allows you to use any terminal or bash tools that are already in existance instead of writing new scripts for the same job. This is particularly important when redirecting input and output from java code which is something you are going to have to do over and over again in this class. The earlier you get comfortable with it, the better for you.\nOther than redirecting output, there are multiple things one can do with terminal and/or bash. https://goo.gl/YzMeBm\nThe link above is to a series of short (a couple of minutes each) tutorials on easy bash tasks that you can learn to do on terminal. They don’t have any direct impact on your java programming but I would highly encourage that you at least take a look at the first few videos and see what I am talking about when I say that you will want to be good at using terminal…and it will take repetition and time. Once you get comfortable with it, you will find that it will be considerably faster than your usual point and click techniques that you are used to and any time you spent watching this videos and trying out some of those commands will be time well spent…trust me. Once you have the latest java jdk installed on your machine, you will have to make sure that it can be compiled and executed from the command line. This is particularly involved with windows machines. Compiling and executing a java file should be automatic with linux machines. Keep track of where (which folder) you installed java on your window system since you will need that information later. Particularly the bin folder. Typically it will be located at  C:\\Program Files\\Java\\jdk1.8.0_31\\bin  This might look different for your own windows computer and so make sure you can find it. You will then need to edit your path variable (under SYSTEM VARIABLES) and add your folder location to it. If done properly, the commands java and javac should return some intelligible information when typed into the terminal. https://goo.gl/dxHUkg"
  },
  {
    "objectID": "lesson0_1.html#why-java",
    "href": "lesson0_1.html#why-java",
    "title": "Introduction",
    "section": "",
    "text": "Java is a formal programming language and one of the most common in use today. Because of that, it is almost impossible to have a career in some form of programming and not use java. It is faster than python (particularly for larger programs) and a lot of the security features it possesses allow you to write programs that will crash less often when run. It is also easy to be used by more than one programmer when a team is working on a project together."
  },
  {
    "objectID": "lesson0_1.html#our-first-java-programagain.",
    "href": "lesson0_1.html#our-first-java-programagain.",
    "title": "Introduction",
    "section": "",
    "text": "class Trial\n{\n   public static void main(String [] args)\n   {\n      System.out.println(“Hello World!”);\n   }\n}\n The code above is the java version of the famous hello world program. Before we get bogged down with the differences between java and python, we shall run this program (using terminal). You might recall that java is an interpreted language. This means that running ajava program is a two step process i.e. compiling and execution. Compiling allows the computer to convert the java program into a form that is easy to distribute and execute on multiple systems. It also allows the computer to quickly identify potential errors and bring them to your attention before you execute the program. Contrast this with Python which is a scripted language and therefore has to be distributed as the source file. Additionally many of the errors could only be identified during the program execution which one could argue it too late for errors to be found. To compile, navigate to the folder/directory in which the .java file is, and then run the command:  javac filename.java  If there aren’t any syntax errors, then the command above should NOT return any message or output. It should however create a file (Trial.class) whose name depends on the names of the classes in the java files. To execute the program, run the command:  java Trial  This should produce the appropriate/expected output to the terminal. If your java program contained multiple classes, then the compilation would produce multiple class files. To execute your program, you would run the command above using whichever class file contained the “main program.” So now let’s discuss the actual program. Even with something as small as this program, you should be able to notice a few differences from python. First off, everything in Java is in a class. There can’t be a statement, function, etc. that is not in a class. So even for a simple hello world, we have to make a class. Classes, functions, and code blocks in general are delineated by curly braces. They show where the code blocks start and end. In python, such blocks were marked by a uniform indentation. While indentation is HIGHLY encouraged in Java, it is not strictly enforced. Statements in java are ended using a semi-colon. Consider it the full stop or period of the java programming language. Without it, the compiler will assume that the next statement is just a continuation even if there are multiple spaces and or lines between them. The reason for this is that it is common in java to have statements that span multiple lines while that was very infrequent in python.Statements that you want to be executed should be put into functions/methods.You can have any number of functions in the class but there must be a main function. This function can be compared to the conductor of an orchestra. It is the function that the compiler will begin and end its execution with. The main function is in charge of determining which other functions will be executed if any at all. Interestingly, it doesn’t have to be at the top of the class but it being at the top of the class might help with readability of your code. The main program has a specific signature or name i.e.\npublic static void main(String [] args)\n\n\n\n\n\n\nNote\n\n\n\nMemorize it because you will be writing it for every single Java program you write."
  },
  {
    "objectID": "lesson0_3.html",
    "href": "lesson0_3.html",
    "title": "0.3 Data structures",
    "section": "",
    "text": "A short introduction on Data structures\nYou don’t have to search for long to see different ways of organizing data in real life situations. Standing in line at the cafeteria, picking the winner in a March Madness bracket, writing down a shopping list, etc. All these examples allow us to use a certain resource in a manner that makes life somewhat easier. Computer Science, as a field, borrows a lot of these ideas in organizing data. The way that a programmer views and organizes the data that his/her program is using has bearing on the success/failure of multiple algorithms. Whereas the primitive types (int, float, double, long, char, byte, short, boolean) are adequate for simple programs, most programs you’ll be writing deal with large amounts of complicated and related data. In order to deal with such data, some structures have been used to represent this data and its relationships.\n\nSome data structures are based on how the programmer organizes the data i.e. how it is organized in memory. These structures are typically used as the basic building blocks of other structures. It is important to remember that with these structures, the implementation of the organization is what is important…more important than what kind of data is being organized, or when that data was encountered and/or organized.\n\nArrays are the most basic. Recall from the Living with Cyber classes, that arrays are used to store similar data in contiguous memory locations. They are available in almost all programming languages and data is accessed using its relative position (i.e. index)\nLinked Lists are also used to store elements in a sequence. However, the data is stored in nodes. Each node has one piece of data, as well as a link showing the location of the next node in the sequence. Think of a chain link.\n\n\nThese two basic structures are the building blocks of the other category of data structures i.e. those that are based on how the programmer views the data. Because these structures are based on how data is viewed (as opposed to how they are organized), sometimes these are called Abstract Data Types (remember “abstract” as a term refers to interpretation separate from concrete reality). These data structures are therefore independent of the implementation which is a concept that can be a little confusing the first time you hear about it.\n\nStacks are data structures that arrange data based on when that data was encountered. In this case, the last in is also the first out (LIFO). Compare this to a stack of plates at Tech Table. This way of looking at a data structure has nothing o do with how it is implemented. It could be an array or linked list (behind the scenes). As long as the data structure works in a LIFO manner, then it can be called a stack.\nQueues also arrange data based on when it was encountered but in a First In, First Out (FIFO) manner. Compare this to an orderly line to get your school identity card. Any piece of data removed from a queue is the piece of data that has been in the queue the longest.\nList is just a linear arrangement of data. It could be an array or linked list (behind the scenes) but as long as it supports the arrangement of data in a linear manner, it can be referred to as a list. Sometimes lists can also be sorted.\nMaps (a.k.a dictionaries, tables, associative arrays) are used to store key-value pairs. They allow the user quick access to a value when provided with the key. Compare it to your phone address book which hopefully provides you with a value (phone number, address, and message history) for every key (contact name) that you provide. Keys should be unique and each key should map to a single value.\nTrees are non-linear data structures. Data arranged in a tree stores both the value and some kind of relationship between those values. The restriction in trees is that each node is capable of having multiple successor nodes, but only one parent node. The parent of all nodes (without a parent itself) is called the root. Think about a tournament bracket.\nGraphs are also non-linear data structures but with less restrictions on the intra node relationships. Any node (typically called a vertex) can be connected (through an edge) to any other vertex. Sometimes even the edges have weights associated with them. Think road or airline routes.\n\n\n\nThere are some basic definitions we need to get out of the way before we dive into more complicated stuff.\nType: a collection of values. For example, a boolean type is collection of two values – true and false. A simple type (such as boolean or integer) will not have subparts, whereas an aggregate or composite type will contain several pieces of information.\nData item: a data item is a member of the type i.e. a piece of information derived from a type.\nData type: This is a combination of a type (the values) and the operations that can be applied to that type. For example, given the possible values of an integer (-231 – 231 -1), possible operations include addition, subtraction, division, etc.\nThere is a difference between the logical concept of a data type and its physical implementation (even if the line is blurred). Consider an array: Its logical concept is that of potentially homogeneous data items stored in a collection where each item is accessed using an index number. However, its physical implementation is a block of contiguous memory locations. The distinction between the two needs to be made because there are cases where arrays (particularly multi-dimensional arrays) have been designed with the same logical idea, but different physical implementation (i.e. the data items are not in contiguous memory locations) but that doesn’t make them any less of an array than a typical array. Another example is the list. Its logical concept is a collection of items, but its physical implementation could be either an array or a linked list. Both are lists, but they have very different physical implementations.\nAbstract data type: When the idea of a data type is realized as a software component i.e. the type and operations are realized in code. This is typically represented by an interface. It does NOT specify how the data type is implemented. In fact, such details are typically hidden from the user of the data type or any outside access.\nData structure: The complete implementation of an ADT. It typically takes the form of a class where the operations of the ADT are captured by member functions of that class.\nAn integer as well as the operations that an integer can be put through make up the integer data type. The java int variable is a physical representation of the abstract integer. This variable, alongside the java int operations make up an ADT. But there is difference between the two (i.e. a difference between a java int ADT and the abstract integer). The java int ADT can only support values within a certain range and we know that real integers do not have that limitation. If this limitation is a deal breaker for you, then you will have to figure out a different ADT (with different implementations) to represent your integers. \n \n    Ref:\nA Practical Introduction to Data Structures and Algorithm Analysis, Clifford A. Shaffer ; Object Oriented Data Structures using Java (4th Edition). Nell Dale, Daniel T. Joyce, Chip Weems."
  },
  {
    "objectID": "lesson2.html",
    "href": "lesson2.html",
    "title": "List Processing",
    "section": "",
    "text": "So we’ve programmed the easylist which used an array for its implementation. Now we have the background to discuss some of the common manipulations that are used on list and how efficient they are. Recall that the whole reason behind data structures is to arrange data in such a way that it can be manipulated efficiently. What exactly is a list anyway? It is a set of values of the same type, and as we’ve seen, arrays are perfect for storing such kinds of data. As you may have noticed before, many data structures in computer science are based on methods of arrangement that occur in real life, and lists are not an exception. If you ever get confused, just visualize a physical list e.g. a shopping list like the one you’d use to buy groceries. Now we know how it looks like, what kind of operations/manipulations do we typically do with a list? - Insert an item in the list - delete an item from the list - search the list - sort the list"
  },
  {
    "objectID": "lesson2.html#insertion",
    "href": "lesson2.html#insertion",
    "title": "List Processing",
    "section": "1 Insertion",
    "text": "1 Insertion\nThis is a very basic operation for a list: We just insert an item at the end of the list. This operation doesn’t depend on how many items (or pieces of data) are already in the list. Therefore its complexity in the big-O notation is \\(O(1)\\)."
  },
  {
    "objectID": "lesson2.html#deletion",
    "href": "lesson2.html#deletion",
    "title": "List Processing",
    "section": "2 Deletion",
    "text": "2 Deletion\nDeleting an item from a list is slightly more involved. We first have to search for the item that we have to delete, delete it, and then shift the remaining elements to cover up the space we just freed up. Its complexity is \\(O(n)\\) because the process grows linearly with the size of data that you are dealing with. On average, we’ll compare \\(n/2\\) items, and shift \\(n/2\\) items to the left."
  },
  {
    "objectID": "lesson2.html#searching",
    "href": "lesson2.html#searching",
    "title": "List Processing",
    "section": "3 Searching",
    "text": "3 Searching\nTo search through our list, we need three things: the list itself, its length, and the item for which we are going to search. Typical search algorithms will return \\(a -1\\) if the value for which we are searching is not found. If the value is found, it will return the index of the item. There are different kinds of searching algorithms that you can employ on your list.The most basic is the linear or sequential search. It starts at the beginning of the array and searches until either we find the item, or we reach the end of the array\n//Sequential/Linear Search\n\nint LinearSearch(int [] list, int item)\n{\n    for(int i=0; i&lt;list.length; i++)\n    {\n        if(list[i] == item)\n            return i;\n    }\n    return -1;\n}\nSo what about the performance of this search? Imagine our list has 1000 items. If the item we are searching for is near the front, the search will be fast, but if its near the end of the list, the search will be long.\nIts complexity is \\(O(n)\\). On average, we’ll compare \\(n/2\\) items.\nSo how can it be improved? Well if the list was ordered, then we wouldn’t have to search all the way to the end to figure out that the key we were searching for wasn’t in the list. We would know that a key isn’t in the list as soon as we found value larger (or smaller…depending on how your list is ordered) than the key we were looking for.\n//Ordered Sequential/Linear Search\n\nint OrderedLinearSearch(int [] list, int item)\n{\n    for(int i=0; i&lt;list.length; i++)\n    {\n        if(list[i] == item)\n            return i;\n        if(list[i] &gt; item)\n            return -1;\n    }\n    return -1;\n}\nIf the list was ordered, we could also employ a binary search which is a slightly more complicated algorithm but would perform much faster.\n//Binary Search\n\nint BinarySearch(int [] list, int item)\n{\n    int first = 0;\n    int last = list.length -1;\n    int mid;\n    while(first &lt;= last)\n    {\n        mid = (first + last) / 2;\n        if(list[mid] == item)\n            return mid;\n        if(list[mid] &gt; item)\n            last = mid – 1;\n        else\n            first = mid + 1;\n    }\n    return -1;\n}\nWhat is the complexity for a binary search? \\(O(log n)\\). Just so you remember, the division to find the mid is integer division. For example, if the list had 100 elements (indices 0 to 99), then mid would evaluate to \\(99/2=49\\)."
  },
  {
    "objectID": "lesson2.html#sorting",
    "href": "lesson2.html#sorting",
    "title": "List Processing",
    "section": "4 Sorting",
    "text": "4 Sorting\nAnother common operation for lists is sorting them. Why? Did you see how much faster a binary search is than a sequential search? If you are going to be doing a lot of searching on your list, it makes sense to sort them at the beginning so that you can save on time when it comes to searching.Alternatively, if you are going to be doing very little searching in your list, then maybe sorting would take up too much time.\nSo how do we sort? Its very easy for us as humans to do with small data sizes because we can see multiple pieces of data at the same time, do loads of comparisons in a short time, etc. But what about a computer? Is there a way that we can design an algorithm to sort the data in a sequence of steps that will always work regardless of how the data looks in the first place?\nLet’s see if you can sort the provided playing cards in non-descending order. Now can you figure out a sequence of steps to describe the process you just went through? A sequence that will always work?\n\n4.1 Bubble Sort\n//Bubble Sort\n\nvoid BubbleSort(int [] list)\n{\n    for(int i=1; i&lt;list.length; i++)\n    {\n        for(int j=1; j&lt;list.length-i+1; j++)\n        {\n            if(list[j] &lt; list[j-1])\n            {\n                int temp = list[j];\n                list[j] = list[j-1];\n                list[j-1] = temp;\n            }\n        }\n    }\n}\nLet’s assume that we want to sort the list in increasing order. Bubble sort works by making successive swaps in such a way as to move the largest element to the endof the array. That way the larger values “bubble” to the end of the array.\nThe inner loop affects a single pass through the list, and controls how many comparisons are carried out in each pass.\nThe outer loop controls the number of passes through the array.\nTo sort a list of \\(n\\) elements, this algorithm will take \\(n-1\\) passes.\nIn each pass, it will make between \\(n-1\\) and comparisons. This totals up to \\(n(n−1)/2\\) comparisons. On average, only half of those comparisons will result in a swap, i.e. \\(n(n−1)/4\\) swaps. This means that for a list of 1000 elements, bubble sort would require about 500,000 comparisons, and 250,000 swaps on average. This represents a complexity of \\(O(n^2)\\).\n\n\n\n\n\n\n\n\n\nPass\nComparisons\nList\nIndices Compared\n\n\n\n\n\n\n9 5 7 1 3\n\n\n\n1\n4\n5 7 1 3 9\n\\(0/1, 1/2, 2/3, 3/4\\)\n\n\n2\n3\n5 1 3 7 9\n\\(0/1, 1/2, 2/3\\)\n\n\n3\n2\n1 3 5 7 9\n\\(0/1, 1/2\\)\n\n\n4\n1\n1 3 5 7 9\n\\(0/1\\)\n\n\n\nOne of the weaknesses with the bubble sort is that even if the input is already sorted, it will still go through all the passes before ending.Fortunately, there is a way to make it optimized.\n//Optimized Bubble Sort\n\nvoid OptimizedBubbleSort(int [] list)\n{\n    boolean swapMade;\n    for(int i=1; i&lt;list.length; i++)\n    {\n        swapMade = false;\n        for(int j=1; j&lt;list.length-i+1; j++)\n        {\n            if(list[j] &lt; list[j-1])\n            {\n                int temp = list[j];\n                list[j] = list[j-1];\n                list[j-1] = temp;\n                swapMade = true;\n            }\n        }\n        if(!swapMade)\n            break;\n    }\n}\n\n\n4.2 Selection Sort\nSelection sort works by identifying the smallest element in the list, and placing it in the first position (using a single swap). It then starts at the second position and finds the next-smallest item and places it in the second position (also using a single swap). It does this process repeatedly: finding the smallest item in the unsorted part of the list, and placing it in its proper position in the sorted part of the list. The left side of the list is the sorted part, and the right hand side is the unsorted part.\n//Selection Sort\n\nvoid SelectionSort(int [] list)\n{\n    for(int i=0; i&lt;list.length-1; i++)\n    {\n        int minIndex = i;\n        for(int j=i+1; j&lt;list.length; j++)\n            if(list[j] &lt; list[minIndex])\n                minIndex = j;\n        int temp = list[i];\n        list[i] = list[minIndex];\n        list[minIndex] = temp;\n    }\n}\nOn average, for a list of size n, it still requires $ n(n−1)/2 $ comparisons, but only \\((n−1)\\) swaps which is considerably less than the bubble sort that we looked at earlier. For example, a list of 1000 elements would require approximately 500,000 key comparisons, but only 1000 swaps.\nIts complexity is still \\(O(n^2)\\).\nIts useful with small amounts of data, in particular when swapping is time consuming.\n\n\n\nPass\nComparisons\nList\n\n\n\n\n\n\n9 5 7 1 3\n\n\n1\n4\n1 5 7 9 3\n\n\n2\n3\n1 3 7 9 5\n\n\n3\n2\n1 3 5 9 7\n\n\n4\n1\n1 3 5 7 9\n\n\n\n\n\n4.3 Insertion Sort\nInsertion sort is the kind of sorting that we typically use as humans. We assume that the first part of the list is sorted, and the latter part is unsorted. We then move one item at a time from the unsorted part to the sorted part making sore to put it in its right position in order to maintain the “sortedness” of the sorted part.\n//Insertion Sort\n\nvoid InsertionSort(int [] list)\n{\n    for(int i=1; i&lt;list.length; i++)\n    {\n        if(list[i] &lt; list[i-1])\n        {\n            int j, temp = list[i];\n            for(j=i-1; j&gt;=0 && list[j]&gt;temp; j--)\n                list[j+1] = list[j];\n            list[j+1] = temp;\n        }\n    }\n}\nOn average, for a list of size n, it takes \\(n(n−1)/2\\) comparisons, and \\(n(n−1)/4\\) swaps which amounts to a complexity of \\(O(n^2)\\). However, with an almost sorted list, it takes almost \\(O(n)\\). This means that it is the best algorithm to use for an almost sorted list.\n\n\n\n\n\n\n\nPass\nList\n\n\n\n\n\n9 5 7 1 3\n\n\n1\n5 9 7 1 3\n\n\n2\n5 7 9 1 3\n\n\n3\n1 5 7 9 3\n\n\n4\n1 3 5 7 9"
  },
  {
    "objectID": "lesson2.html#recap",
    "href": "lesson2.html#recap",
    "title": "List Processing",
    "section": "5 Recap",
    "text": "5 Recap\n\nFor each sort, sorting n elements takes n-1 passes.\nEach sort maintains a sorted and unsorted side.\n\nBubble: unsorted = left, sorted = right\nSelect: unsorted = right, sorted = left\nInsertion: unsorted = right, sorted = left\n\nA single element is trivially sorted.\nTo differentiate between the different kinds of sorts\n\nBubble: on each pass, largest item in unsorted side “bubbles” to end of unsorted side. Requires many swaps, and many comparisons.\nSelect: on each pass, smallest item in unsorted side moves to beginning of unsorted side. Requires few swaps, but many comparisons.\nInsertion: on each pass, first item in unsorted side moves to its proper place in sorted side. Some swaps, some comparisons.\n\nSequential search on an ordered list can abort search early if current element is greater than the key we are searching for. On average, it takes \\(n/2\\) key comparisons but is a bit better than sequential search on an un-ordered list. On the down side, insertion into an ordered list is more costly. Complexity of a sequential search is \\(O(n)\\).\nBinary search can only be used when the list is sorted. It uses a divide and conquer technique. It is usually applied to array based lists since its easy to find the middle element \\((first+last)/2\\). If the middle element is what we are searching for, then we’re done. If its less than what we are searching for, we search in the list to the right, otherwise, we search in the list to the left. We keep on repeating this process till we find the key (or don’t find it). Complexity of binary search is \\(O(lg n)\\)."
  },
  {
    "objectID": "lesson4.html",
    "href": "lesson4.html",
    "title": "Stacks and Queues",
    "section": "",
    "text": "In this chapter, we are going to discuss two very useful data structures i.e. stacks and queues, both of which are applied in various places in Computer Science."
  },
  {
    "objectID": "lesson4.html#stack-operations",
    "href": "lesson4.html#stack-operations",
    "title": "Stacks and Queues",
    "section": "1.1 Stack Operations",
    "text": "1.1 Stack Operations\nSo what are the operations that the stack data structure supports?\nSince we can add items to a stack, the stack data structure supports an add operation, typically referred to as push. We can also retrieve and remove the top element from a stack, and therefore the stack supports top and pop operations. Top retrieves the top element from the stack, and pop removes the top element from the stack. Alternative implementations combine this operation into pop, and then provide a peek function to retrieve the top elements information without removing it from the stack.\nAn element can only be added to a stack (push) if there is room, and an element can only be removed from the stack (pop) if there is something in the stack. This dictates the need for IsEmpty and IsFull functions. To know whether a stack IsFull, we’d need to know its size.\nIn summary, a stack should support the following functions:\n\nPush\nPop\nPeek\nSize\nIsEmpty\nIsFull"
  },
  {
    "objectID": "lesson4.html#stack-uses",
    "href": "lesson4.html#stack-uses",
    "title": "Stacks and Queues",
    "section": "1.2 Stack Uses",
    "text": "1.2 Stack Uses\nOne of the most common uses of stacks in a computer is in keeping track of the functions that are called duing program execution. Suppose that your main calls function A, which calls B, which calls C, which calls D. When D terminates, control goes back to C. When C terminates, control goes back to B, and so on and so forth. You’ll notice that the order in which the functions were encountered is opposite to the order in which the control returns. A stack lends itself easily to such scenarios.\nAnother example of stack use is in reversing words. If the letters of the word are pushed onto a stack in the order in which they are encountered, then they can be popped of in the reverse order.\npush R          //in what order will the word “RACECAR” be popped after being \npush A          //pushed onto a stack?\npush C\npush E\npush C\npush A\npush R\n…\npop R\npop A\npop C\npop E\npop C\npop A\npop R\nAnother example of stack use is in matching brackets. The way that works is if we follow this rule: push left parentheses, ignore operators and operands, and pop the stack whenever we get a right parenthesis to make a match.\nSee if you can follow the follow the input and stack umns for the expression \\(a+b*(c+(d-e)/(f/g))\\)\n\n\n\nInput\nStack\nInput\nStack\n\n\n\n\na\n\ne\n((\n\n\n+\n\n)\n(\n\n\nb\n\n/\n(\n\n\n*\n\n(\n((\n\n\n(\n(\nf\n((\n\n\nc\n(\n/\n((\n\n\n+\n(\ng\n((\n\n\n(\n((\n)\n(\n\n\nd\n((\n)\n\n\n\n-\n(("
  },
  {
    "objectID": "lesson4.html#stack-complexity",
    "href": "lesson4.html#stack-complexity",
    "title": "Stacks and Queues",
    "section": "1.3 Stack Complexity",
    "text": "1.3 Stack Complexity\nThe size of the data in a stack doesn’t affect how quickly we can perform a push or pop operation. As a result, the complexity for either one of those operations is \\(O(1)\\)."
  },
  {
    "objectID": "lesson4.html#queue-operations",
    "href": "lesson4.html#queue-operations",
    "title": "Stacks and Queues",
    "section": "2.1 Queue operations",
    "text": "2.1 Queue operations\nSimilar to a stack, a queue is also a lection of homogeneous elements. However, the way that we interact with the queue is different. Elements are added to the queue from the back (enqueue) and are removed or deleted from the front of the queue (dequeue). Other than that, the operations that you would find in a stack are also found in a queue i.e. Peek, Size, IsEmpty, and IsFull."
  },
  {
    "objectID": "lesson4.html#queue-complexity",
    "href": "lesson4.html#queue-complexity",
    "title": "Stacks and Queues",
    "section": "2.2 Queue complexity",
    "text": "2.2 Queue complexity\nSimilar to a stack, the process of enqueuing and dequeuing does not depend on the size of the data already stored in the queue. As a result, their complexity is \\(O(1)\\)."
  },
  {
    "objectID": "lesson4.html#priority-queues",
    "href": "lesson4.html#priority-queues",
    "title": "Stacks and Queues",
    "section": "2.3 Priority queues",
    "text": "2.3 Priority queues\nSometimes first in, first out isn’t good enough. For example if you’ve just won the lottery and yet you’re stuck in a long line just to get to a ride at Disney world. Priority queues allow items to be ordered by a key. Each element is inserted into the queue at a position that is related to how important it is. The more important, the closer to the front that element is. Dequeuing is the same as in an ordinary queue with the element at the front of the queue removed first.\nBecause enqueuing requires finding the appropriate position for that element, enqueuing is now \\(O(n)\\), but dequeuing is still \\(O(1)\\)."
  },
  {
    "objectID": "lesson4.html#converting-from-infix-to-postfix",
    "href": "lesson4.html#converting-from-infix-to-postfix",
    "title": "Stacks and Queues",
    "section": "3.1 Converting from infix to postfix",
    "text": "3.1 Converting from infix to postfix\nTo convert from infix to postfix, we have to remember that:\n\nwe carry out our evaluations from left to right\nthe operands should ALWAYS be in their original order\nan operator should ALWAYS be placed after the operands on which it will operate. (it doesn’t have to be immediately after)\n\nIt might be simple to see how to get from infix to postfix with short expressions but it gets complicated real quick with longer expressions. I suggest grouping and numbering different operations in order to guide you in converting from infix to postfix."
  },
  {
    "objectID": "lesson4.html#evaluating-postfix-expressions.",
    "href": "lesson4.html#evaluating-postfix-expressions.",
    "title": "Stacks and Queues",
    "section": "3.2 Evaluating postfix expressions.",
    "text": "3.2 Evaluating postfix expressions.\nAs we mentioned earlier, we use a stack to evaluate postfix expressions. But how exactly? We go through the postfix expression from left to right. If we encounter an operand, we push it onto the stack. However, If we encounter an operator, we pop the top two items from the stack, evaluate it, and push the result back onto the stack.\na = Pop();\nb = Pop();\nPush(eval(a, b));\nFor example, if our postfix expression was 5 2 9 * +\n\n\n\ninput\nstack\n\n\n\n\n5\n5\n\n\n2\n2 5\n\n\n9\n9 2 5\n\n\n*\n18 5\n\n\n+\n23\n\n\n\nAlternatively, if our expression was 7 5 + 9 * 6 +\n\n\n\ninput\nstack\n\n\n\n\n7\n7\n\n\n5\n5 7\n\n\n+\n12\n\n\n9\n9 12\n\n\n*\n108\n\n\n6\n6 108\n\n\n+\n114"
  },
  {
    "objectID": "lesson4.html#converting-from-infix-to-postfix-1",
    "href": "lesson4.html#converting-from-infix-to-postfix-1",
    "title": "Stacks and Queues",
    "section": "3.3 Converting from infix to postfix",
    "text": "3.3 Converting from infix to postfix\nBoth stacks and queues can be used to convert an expression from infix to postfix.\nThe infix expression is read out of a queue, and the postfix expression is stored in another queue. The operands are transferred from the infix queue to the postfix queue in their proper order. However, operators are stored on a stack and then removed and put into the postfix queue in their appropriate position.\nSo what exactly determines the appropriate position of an operator? Its position is dependent on arithmetic hierarchy of operators and is used to determine how long the operator will remain on the stack before being popped and enqueued to the postfix queue.\nFor example, we can rank operators that we would expect to find in an infix expression.\n\n\n\nToken\n(\n^\n*\n/\n+\n-\ndefault\n\n\n\n\nValue\n4\n3\n2\n2\n1\n1\n0\n\n\n\nThe ranking above puts priority on parentheses and exponents.\nWe can also rank operators that we would find in a postfix expression.\n\n\n\nToken\n^\n*\n/\n+\n-\ndefault\n\n\n\n\nValue\n2\n2\n2\n1\n1\n0\n\n\n\nThe ranking above reflects the idea that our postfix expression would not have parentheses. Otherwise it looks exactly the same as the one before except that ^ no longer has as high of a value. This is to make sure that if we come across a ^ in the infix expression, it has a higher priority than a ^ that might be on the stack. If they were the same rank, then the expression                      2 ^ 3 ^ 2\nwould have the same answer whichever way you evaluated it. As it turns out, (2^3)^2 gives a different answer from 2^(3^2) and the correct one is the latter i.e. 512.\nThe actual algorithm for converting from infix to postfix is given below.\nWe shall use it to convert a few examples of expressions and hopefully it’ll become clearer.\nThe expression that we will convert is 3 * 4 - ( 7 – 8 / 2 )\n    infixQ ← infix expression\n    postfixQ ← empty queue\n    operS ← empty stack\n    repeat\n        token ← infixQ.dequeue()\n        if token is an operand\n        then\n            postfixQ.enqueue(token)\n        else if token is a right parenthesis\n        then\n            op ← operS.pop()\n            while op is not a left parenthesis\n                postfixQ.enqueue(op)\n                op ← operS.pop()\n            end\n        else\n            op ← operS.peek()\n            while stack_priority(op) &gt;= infix_priority(token)\n                op ← operS.pop()\n                postfixQ.enqueue(op)\n                op ← operS.peek()\n            end\n            operS.push(token)\n        end\n    until infixQ is empty\n    while operS is not empty\n        op ← operS.pop()\n        postfixQ.enqueue(op)\n    end\n\n\n\nInfix queue\ntoken\nOperator stack\nPostfix queue\n\n\n\n\n3 * 4 - ( 7 – 8 / 2 )\n\n\n\n\n\n* 4 - ( 7 – 8 / 2 )\n3\n\n3\n\n\n4 - ( 7 – 8 / 2 )\n*\n*\n3\n\n\n- ( 7 – 8 / 2 )\n4\n*\n3 4\n\n\n( 7 – 8 / 2 )\n-\n-\n3 4 *\n\n\n7 – 8 / 2 )\n(\n( -\n3 4 *\n\n\n– 8 / 2 )\n7\n( -\n3 4 * 7\n\n\n8/ 2)\n-\n- ( -\n3 4 * 7\n\n\n/ 2)\n8\n- ( -\n3 4 * 7 8\n\n\n2)\n/\n/ - ( -\n3 4 * 7 8\n\n\n)\n2\n/ - ( -\n3 4 * 7 8 2\n\n\n\n)\n-\n3 4 * 7 8 2 / -\n\n\n\n\n\n3 4 * 7 8 2 / - -\n\n\n\nAnd therefore the final postfix expression is 3  4 * 7 8 2 / - -"
  },
  {
    "objectID": "lesson5b.html",
    "href": "lesson5b.html",
    "title": "5(b): Generics",
    "section": "",
    "text": "We are going to take a detour and discuss generics in java. Recall that method declarations in java typically have a data type associated with it. This allows the compiler to do some checking to make sure that our functions are used for the purposes for which we designed them and only deal with the data they’ve been designed to deal with. Sometimes, however, that can be very restrictive and lead to code duplication.\n\n1 Generics: The case for\nImagine a very simple situation where you have to design a function that printed out the elements of an array that it received as an argument. Your first attempt might look something like this.\npublic static void printArray(int [] arr)\n{\n    for (int i = 0; i &lt; arr.length; i++)\n    System.out.print(arr[i] + “, “);\n    System.out.println();\n}\nWhich is a very good attempt…until you realise that the function calling the printArr function will not always send you an integer array\npublic static void main(String [] args)\n{\n    int [] x = {1, 2, 3, 4, 5, 6, 7};\n    printArr(x);\n\n    double [] y = {1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7};\n    printArr(y);\n    \n    // ...\n}\nYour first attempt to resolve this issue could be overloading the printArr function (i.e. creating another printArr func tion that has a different signature just to deal with the doubles).\npublic static void printArray(int [] arr)\n{\n    for (int i = 0; i &lt; arr.length; i++)\n    System.out.print(arr[i] + “, “);\n    System.out.println();\n}\npublic static void printArray(double [] arr)\n{\n    for (int i = 0; i &lt; arr.length; i++)\n        System.out.print(arr[i] + “, “);\n    System.out.println();\n}\nBut this approach leads to a lot of code duplication. Suppose you also need a printArr for characters, etc.\nGenerics allow us to form our own type names as a place holder for whatever typethe function (or class) eventually ends up dealing with. That way, you can have a function that will work when it is given integers, or doubles, or characters.\n\n\n2 Generic Methods\nDesigning methods to deal with generics requires a few changes from our typical method/function design.\n\nThe function signature now also has a type parameter section that comes before the return type of the method. The type parameter section starts with a &lt; and ends with a &gt;.\nThe type parameter section contains one or more identifier names that you as the programmer choose as a place holder for any type that the function will end up dealing with. If one ends up using more than one generic type inthe same function, the identifier names are comma separated.\nThese identifier names can then be used to declare the return type or the types of arguments that the function will be receiving as parameters.\nThe body of the function looks very similar to a normal function body. Keep in mind that the identifier name is used instead of the more restrictive type. These types can only be used as place holders for types that are passed by reference and not by value. This means that it won’t work for primitive types such as int, char, double, but it will work for object types such as Integer, Character, Double, or any objects from classes that we have designed ourselves.\n\npublic static &lt;mytype&gt; void printArray(mytype [] arr)\n{\n    for (int i = 0; i &lt; arr.length; i++)\n        System.out.print(arr[i] + “, “);\n    System.out.println();\n}\npublic static void main(String [] args)\n{\n    Integer [] x = {1, 2, 3, 4, 5, 6, 7};\n    printArr(x);\n    \n    Double [] y = {1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7};\n    printArr(y);\n    // ...\n}\n\n\n3 Generic Classes\nSometimes the instance variables in a class (as well as a few functions) need to be unshackled from just one type. For example, perhaps you want your List to be able to store more than just ints.\nFor this to work, the parameter type section has to be included in the class definition after the class name (but before the opening curly brace).\nWhen the objects are being declared, the actual data type has to be used.\nclass Node&lt;mytype&gt;\n{\n    private mytype data;\n    private Node link;\n    \n    public mytype getData()\n    {\n        return this.data;\n    }\n    \n    // other functions\n}\n\nclass NodeTest\n{\n    public static void main(String [] args)\n    {\n        Node&lt;Integer&gt; a = new Node&lt;Integer&gt;(); // node storing an integer\n        Node&lt;Double&gt; b = new Node&lt;Double&gt;(); // node storing a double\n        Node&lt;Character&gt; c = new Node&lt;Character&gt;(); // node stores characters.\n        //…\n    }\n}\n\n\n\n\n\n\ndemo with examples of generic methods and classes. Make sure to show and interpret the error messages that are shown as a result.\n\n\n\n\n\n4 Bounded type parameters\nSometimes the flexibility afforded by generic types is too much and you want to limit it a little i.e. allow only some types but not every single type. In this case, you adjust the type parameter from just having an identifier name, but also the extends keyword followed by an upper bound. This upper bound can be a super class or interface that all the types you actually want to allow belong to.\npublic static &lt;mytype extends Number&gt; mytype getMax(mytype a, mytype b)\n{\n    if (a.floatValue() &gt; b.floatValue())\n        return a;\n    return b;\n}"
  },
  {
    "objectID": "lesson6.html#section",
    "href": "lesson6.html#section",
    "title": "Binary Trees",
    "section": "3.3 ",
    "text": "3.3"
  },
  {
    "objectID": "lesson6.html#insertion-into-a-binary-search-tree",
    "href": "lesson6.html#insertion-into-a-binary-search-tree",
    "title": "Binary Trees",
    "section": "3.1 Insertion into a binary search tree",
    "text": "3.1 Insertion into a binary search tree\nYou might have realized that the order of the nodes is important in a binary search tree. Well how do we insert a node into the tree while maintaining all the rules that make it very efficient?\nNodes are ALWAYS inserted as leaves. Remember a leaf is a node that doesn’t have any children. First we search the tree to find the appropriate position for our new leaf node. Compare with the root, and go to the left or right subtree based onthat comparison. Keep on repeating that step until the subtree is NULL. At this point, insert the node and make sure that the node you were in is pointing to the new node using the appropriate link.\nFor example, suppose I wanted to add a 55 to the binary search tree we saw earlier. 55 is less than 60 so we go to the left subtree of the root. It’s greater than 50 so we go to the right subtree of that node. Its less than 58 but there is no left subtree so we add the new node in that position.\n\n\n\n\n\n\n\n\n\n\n\nTry and insert the following nodes to the tree above. 65, 68, 79\n\n\n\n\n/* \n this function inserts the integer x into the tree in the appropriate position \n*/ \nTreeNode insert(int x, TreeNode root) \n{ \n    TreeNode current, trail, newnode; //pointers to the current node, the node before \n    //the current (called trail), and a pointer to the \n    //new node that we will create from int x. \n    \n    newnode = new TreeNode(); //create the new node and initialize it appropriately \n    newnode.setData(x);\n    newnode.setLeft(null);\n    newnode.setRight(null); \n    \n    if (root == null) //if the root is null (i.e. no tree yet), \n        root = newnode; //just set the root to the newnode \n    else \n    { \n        current = root; \n    \n        while (current != null) //this while loop will set trail to the current node and\n        {           //then move \"current\" to the appropriate subtree until\n                    //both current and trail are at the bottom of the tree \n            trail = current; \n            \n            if (current.getData() == x)         //we don't want duplicate values in our tree \n            { \n                System.out.println(“we don’t want duplicate values”);\n                return; \n            } \n            else if (current.getData() &gt; x)      //if x is less, move current to the left subtree \n                current = current.getLeft(); \n            else //otherwise, move current to the right subtree \n                current = current.getRight(); \n    }\n    //right now trail points to the last node before our insertion, and current is null. \n    if (trail.getData() &gt; x) \n        trail.setLeft(newnode); \n    else \n        trail.setRight(newnode); \n    } \n    return root;\n}"
  },
  {
    "objectID": "lesson6.html#finding-the-min-and-max",
    "href": "lesson6.html#finding-the-min-and-max",
    "title": "Binary Trees",
    "section": "3.2 Finding the min and max",
    "text": "3.2 Finding the min and max\nWith a binary search tree, finding the minimum value is just a matter of following the left edges until the left most node. This node is the minimum.\nFinding the maximum is the opposite: follow the right edges until the right most node."
  },
  {
    "objectID": "lesson6.html#deleting-a-node",
    "href": "lesson6.html#deleting-a-node",
    "title": "Binary Trees",
    "section": "3.3 Deleting a node",
    "text": "3.3 Deleting a node\nWe’ve inserted, we’ve searched…last thing to do is delete. Deleting also requires searching for the appropriate node. Good thing we can now do that in \\(O(log_2n)\\).\nThe delete operation shouldn’t change the tree from a binary search tree and this restriction brings up some different cases.\nCase 1: The node to be deleted is a leaf This is the most straightforward case. To delete the leaf, we modify the parent’s link to this node and make it NULL.\nFor example, if we wanted to delete 30 from the tree below on the left, we would just change 50’s left link to NULL.\n\n\n\n\n\n\n\n\n\n\nCase 2: The node to be deleted has one child This case is also fairly straightforward. We simply promote that child to take the position of the parent. This involves making the “grandparent” point directly to the child node. For example, if we wanted to delete 50 from the tree above, we would just promote 58 to level 1 i.e. make it directly connected to 60.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCase 3: The node to be deleted has two children. In this case, we find the node’s successor and swap it with the deleted node. The node’s successor is the next highest node in the binary search tree. To identify it, traverse the right edge, and then traverse left edges until you find a leaf node. For example, if I wanted to delete 60 from the tree above, I would find 60’s successor by traversing the right edge (to 70) and then left edges till I couldn’t find any other left edge (65), and then move 65 to the position that 60 originally held.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWhat if it was a more complicated tree?"
  },
  {
    "objectID": "lesson6.html#printing-trees",
    "href": "lesson6.html#printing-trees",
    "title": "Binary Trees",
    "section": "4.1 Printing trees",
    "text": "4.1 Printing trees\nRecursion provides a pretty nifty way of printing trees. They can be printed from right to left using the function below. In it, the variable lev refers to the number of tabs.\nvoid print(TreeNode n, int lev) \n{ \n    if (n != null) \n    { \n        print(n.getRight(), lev+1);     //go down the right subtree and increase \n                                        //the number of tabs i'll have to make\n        \n        for (int i = 0; i &lt; lev; i++) \n            System.out.print(\"\\t\");     //print out the appropriate no. of tabs\n        System.out.println(n.getData());//and the data, and move to next line\n        \n        print(n.getLeft(), lev+1);      //go down the left subtree and increase \n                                        //tabs\n    } \n}"
  },
  {
    "objectID": "lesson6.html#recreating-a-tree-from-its-inorder-and-preorder-traversals",
    "href": "lesson6.html#recreating-a-tree-from-its-inorder-and-preorder-traversals",
    "title": "Binary Trees",
    "section": "4.2 Recreating a tree from its inOrder and preOrder traversals",
    "text": "4.2 Recreating a tree from its inOrder and preOrder traversals\nThe diagramatic representation of a tree can be recreated from its in order and preorder traversals.\nRemember that inorder is LNR i.e. visit the left subtree, then the node, then the right, whereas preorder is NLR i.e. visit the node first, then the left subtree and end with the right subtree.\nFor example consider the two sequences below.\nInorder:  B C E F G H J K P R S X Z\npreorder: J E B C G F H P K S R X Z\nPreorder starts with the node so we know that J must be the root node. However, Inorder visits the left subtree before getting to the root so we can say that all the letters to the left of J must be in its left subtree i.e. B C E F G and H. Conversely, the right subtree of the root J consists of K P R S X and Z.\nPreorder says our next node (after the root J) is E. From in order, we see that the left subtree of E is B and C, while its right subtree is F, G, and H.\nPreorder dictates that our next node after E is B. The left subtree of B (acc. to the inorder) has nothing, but its right subtree has C (Recall that C is also in the left subtree of E which means that it is to the right of B but left of E).\nI leave it up to you to follow through with all the nodes until you get to the tree shown below."
  }
]