[
  {
    "objectID": "page2.html",
    "href": "page2.html",
    "title": "0.3 Data structures",
    "section": "",
    "text": "A short introduction on Data structures\nYou don’t have to search for long to see different ways of organizing data in real life situations. Standing in line at the cafeteria, picking the winner in a March Madness bracket, writing down a shopping list, etc. All these examples allow us to use a certain resource in a manner that makes life somewhat easier. Computer Science, as a field, borrows a lot of these ideas in organizing data. The way that a programmer views and organizes the data that his/her program is using has bearing on the success/failure of multiple algorithms. Whereas the primitive types (int, float, double, long, char, byte, short, boolean) are adequate for simple programs, most programs you’ll be writing deal with large amounts of complicated and related data. In order to deal with such data, some structures have been used to represent this data and its relationships.\n\nSome data structures are based on how the programmer organizes the data i.e. how it is organized in memory. These structures are typically used as the basic building blocks of other structures. It is important to remember that with these structures, the implementation of the organization is what is important…more important than what kind of data is being organized, or when that data was encountered and/or organized.\n\nArrays are the most basic. Recall from the Living with Cyber classes, that arrays are used to store similar data in contiguous memory locations. They are available in almost all programming languages and data is accessed using its relative position (i.e. index)\nLinked Lists are also used to store elements in a sequence. However, the data is stored in nodes. Each node has one piece of data, as well as a link showing the location of the next node in the sequence. Think of a chain link.\n\n\nThese two basic structures are the building blocks of the other category of data structures i.e. those that are based on how the programmer views the data. Because these structures are based on how data is viewed (as opposed to how they are organized), sometimes these are called Abstract Data Types (remember “abstract” as a term refers to interpretation separate from concrete reality). These data structures are therefore independent of the implementation which is a concept that can be a little confusing the first time you hear about it.\n\nStacks are data structures that arrange data based on when that data was encountered. In this case, the last in is also the first out (LIFO). Compare this to a stack of plates at Tech Table. This way of looking at a data structure has nothing o do with how it is implemented. It could be an array or linked list (behind the scenes). As long as the data structure works in a LIFO manner, then it can be called a stack.\nQueues also arrange data based on when it was encountered but in a First In, First Out (FIFO) manner. Compare this to an orderly line to get your school identity card. Any piece of data removed from a queue is the piece of data that has been in the queue the longest.\nList is just a linear arrangement of data. It could be an array or linked list (behind the scenes) but as long as it supports the arrangement of data in a linear manner, it can be referred to as a list. Sometimes lists can also be sorted.\nMaps (a.k.a dictionaries, tables, associative arrays) are used to store key-value pairs. They allow the user quick access to a value when provided with the key. Compare it to your phone address book which hopefully provides you with a value (phone number, address, and message history) for every key (contact name) that you provide. Keys should be unique and each key should map to a single value.\nTrees are non-linear data structures. Data arranged in a tree stores both the value and some kind of relationship between those values. The restriction in trees is that each node is capable of having multiple successor nodes, but only one parent node. The parent of all nodes (without a parent itself) is called the root. Think about a tournament bracket.\nGraphs are also non-linear data structures but with less restrictions on the intra node relationships. Any node (typically called a vertex) can be connected (through an edge) to any other vertex. Sometimes even the edges have weights associated with them. Think road or airline routes.\n\n\n\nThere are some basic definitions we need to get out of the way before we dive into more complicated stuff.\nType: a collection of values. For example, a boolean type is collection of two values – true and false. A simple type (such as boolean or integer) will not have subparts, whereas an aggregate or composite type will contain several pieces of information.\nData item: a data item is a member of the type i.e. a piece of information derived from a type.\nData type: This is a combination of a type (the values) and the operations that can be applied to that type. For example, given the possible values of an integer (-231 – 231 -1), possible operations include addition, subtraction, division, etc.\nThere is a difference between the logical concept of a data type and its physical implementation (even if the line is blurred). Consider an array: Its logical concept is that of potentially homogeneous data items stored in a collection where each item is accessed using an index number. However, its physical implementation is a block of contiguous memory locations. The distinction between the two needs to be made because there are cases where arrays (particularly multi-dimensional arrays) have been designed with the same logical idea, but different physical implementation (i.e. the data items are not in contiguous memory locations) but that doesn’t make them any less of an array than a typical array. Another example is the list. Its logical concept is a collection of items, but its physical implementation could be either an array or a linked list. Both are lists, but they have very different physical implementations.\nAbstract data type: When the idea of a data type is realized as a software component i.e. the type and operations are realized in code. This is typically represented by an interface. It does NOT specify how the data type is implemented. In fact, such details are typically hidden from the user of the data type or any outside access.\nData structure: The complete implementation of an ADT. It typically takes the form of a class where the operations of the ADT are captured by member functions of that class.\nAn integer as well as the operations that an integer can be put through make up the integer data type. The java int variable is a physical representation of the abstract integer. This variable, alongside the java int operations make up an ADT. But there is difference between the two (i.e. a difference between a java int ADT and the abstract integer). The java int ADT can only support values within a certain range and we know that real integers do not have that limitation. If this limitation is a deal breaker for you, then you will have to figure out a different ADT (with different implementations) to represent your integers. \n \n    Ref:\nA Practical Introduction to Data Structures and Algorithm Analysis, Clifford A. Shaffer ; Object Oriented Data Structures using Java (4th Edition). Nell Dale, Daniel T. Joyce, Chip Weems."
  },
  {
    "objectID": "images/samplecode.html",
    "href": "images/samplecode.html",
    "title": "Java Preliminaries",
    "section": "",
    "text": "a = int(input(\"Enter a number: \"))\nb = int(input(\"Enter another number: \"))\nprint(f\"{a} raised to the power {b} is {a**b}\")\nIf you are using IDLE, this is what your window should look like.\n\n\n\nBasic python file in IDLE"
  },
  {
    "objectID": "Chapter0_2.html",
    "href": "Chapter0_2.html",
    "title": "Chapter 0.2",
    "section": "",
    "text": "If the discussion in this section is a bit too difficult for you to understand, please refer to the last Computer Architecture discussion we had in CSC132. Recall that during our discussion of how a computer works, we talked about the makeup of memory. At a very basic level, memory is made up of “words” which is a unit of memory. Each word has a specific address, and is used to store both data and the instructions that work upon that data. The diagram below shows a sample memory space with 256 words.\n \n\n\n\n\nThe operating system is in charge of mapping variables to addresses and the data stored in that address and there are two main ways that it does this.\nWith direct addressing , the location associated with the variable stores the value of that variable. This is typically the case with primitive data types e.g. characters, int, float, long, etc. The variable is said to be stored by value.\nWith indirect addressing, the location associated with the variable stores the address of another location that has the actual value. Think of it as the memory location is storing the keys of the actual place where the value is stored. This is typically the case with complex data types e.g. strings, objects created from classes, etc. The variable is said to be stored by reference.\n\nchar ch = ‘a’; //direct addressing    \nString str = “dog”;     \n\n/*\nindirect addressing. str has the address 03 and the actual value is found at that address. \nThis consists of the data plus some extra information that could help with some extra manipulation.   \n    \nThis is sometimes represented as    \n\n                str -&gt; dog  \n    \n**spoiler alert: This arrow representation will come back later when we discuss linked lists.*/\n\n\n\n\n\n// This is a basic class representing a circle All it stores is the radius. \n// It has a constructor, an accessor and a mutator.\nclass Circle\n{\n    private int radius;\n\n    public Circle(int radius)\n    {\n        setRadius(radius);\n    }\n\n    public void setRadius(int radius)\n    {\n        if (radius&gt;=0)\n            this.radius = radius;\n        else\n            this.radius =1;\n    }\n\n    public int getRadius()\n    {\n        return this.radius;\n    }\n    \n    public String toString()\n    {\n        return \"This circle has a radius of \" + this.getRadius();\n    }\n}\nGiven the Circle class defined above, let’s write some lines of code and see what happens in memory, and how it can be represented diagramatically. We shall also be manipulating a primitive type (int) so that you can notice the contrast between the two.\n// Simple declaration of two variables. \n// One is an object of type Circle and the other is a primitive integer\nCircle a; \nint x;  \n\nNotice that without any initialization, Java will put some default values in those memory locations. For objects, the default value is null to mean the lack of a reference (or address). The default value for ints is 0.\nFYI null can also be used in object comparison\nif (a== null)\n    System.out.println(“Circle has not been initialized”);\n// Assigning initial values to both a and x. \n// For a, this involves creating a circle object and passing it any required  parameters.\n\na = new Circle(5); \nx = 5; \n\nWhile the location associated with x stores the actual value of x (i.e. 5), the location associated with a stores the address of a location in memory (12AB) where the information representing the circle object is actually stored. This means x is stored by value, and a is stored by reference. Declaration and Initialization can also be done in a single step.\nCircle b = new Circle(7);\nint y = 7;\n\nBoth a and b are objects and therefore are stored by reference while x and y which are primitive types are stored by value.\n\n\n\nWhen a primitive type is assigned, the value stored in the location is copied to the new location.\nx = y;      // This copies the value that was in y into x.\na = b;      // This copies the reference stored in b into a\nHowever, when an object is assigned, whatever is stored in the source location is copied into the target location. Recall that an address/reference is actually what is stored and not the actual value. Therefore object assignment has the unique effect of making both variables refer to the same copy of the object instead of having two copies of the object.\n\nThere are a couple of implications of this behavior.\n\nFirstly, the original circle located at 12AB is no longer accessible. The memory location is being used to store the circle, but that circle can no longer be used since there is no way to get to it. The space it takes up is now referred to as garbage. Java automatically cleans garbage(garbage collection) so that the computer/program has access to that memory eventually. This is not the case in other languages.\n\nCircle c;\nfor (int n = 0; n &lt; 100; n++)\n{\n    c = new Circle(n*2); // create a circle with a radius twice the size of n\n}\n/* Notice that when this loop finishes execution, you will only have access to the last\ncreated circle and not the 99 circles before that (which now constitute garbage) */\n\nSecondly, and perhaps more importantly, since a and b refer to the exact same circle (there are two keys to the same house), then any changes made to the copy a (whether intentional or accidental) also affect the original b.\n\n\n\n\nThat last point we discussed might seem very small and avoidable but in reality it isn’t. That’s because whenever an object is passed as a parameter in a function, it is passed by reference. So even if it might have another variable name in the function, any changes to the object will affect the original object.\nclass Test\n{\n    public static void main(String [] args)\n    {\n        Circle a, b, c;\n        a = new Circle(3);\n        b = new Circle(5);\n        c = combinedCircle(a, b);\n        System.out.println(a); // a will have a radius of 10 because it was changed\n        System.out.println(b); // “unintentionally” in the combinedCircle function.\n        System.out.println(c);\n        }\n    public static Circle combinedCircle ( Circle x, Circle y)\n    {\n        Circle z = new Circle(x.getRadius() + y.getRadius());\n        x.setRadius(10);      // statement that changes one of the input arguments, and \n                              // inadvertently changes the original copy in the process.\n        return z;\n    }\n}\n\n\n\nWe have mentioned how primitive types are stored and passed (i.e. by value) and how objects are stored and passed (i.e. by reference). But what about arrays? Recall that with primitive types, the variable name is mapped directly to a memory location that contains the value associated with that variable (by value). Conversely, with objects, the variable name is mapped to a memory location that contains the address of another place in memory where the object state is being stored (by reference). Arrays (of any type) are treated like objects. That means that the array name is mapped to a memory location that contains the address of the first of a block of memory locations that contain the array elements i.e. arrays are passed by reference. This means that if you pass an array as an argument to a function, that function is in fact dealing with the original array and therefore any changes to the array will last even after control has been passed back to the original function.\nimport java.util.*\nclass Trial\n{\n    public static void main(String [] args)\n    {\n        Random r = new Random();\n        int [] arr = new int [100]; // create an array of 100 integers (by default all set to 0)\n        for (int i = 0; i &lt; arr.length; i++)\n        arr[i] = r.nextInt(1000);   // random integer from 0-1000\n        // Sort the array\n        selectionSort(arr); // Note that this function only takes an argument and does not return\n                            // any values. Nonetheless, it is capable of making changes to the \n                            // original array since it has the reference to that array.\n        // Print out the array\n        for (int i = 0; i &lt; arr.length; i++)\n        System.out.print(arr[i] + “ “);\n    }\n    public static void selectionSort(int [] list)\n    {\n        // a sort function that doesn’t have a return type (i.e. void) but actually affects the \n        // variable in the original function. So in an essence it does return something\n    }\n}\nNotice in the example above how the selectionSort function doesn’t have a return type but is still able to affect a variable in the original main function.\n\n\n\nOccasionally, it is necessary to create an array of objects. If objects are mapped by reference, and arrays are mapped by reference, then what about arrays of objects?\nint [] arr = new int [10]; // an array of primitives (for comparison)\nCircle [] circles = new Circle [10];  // an array of circle objects which by default are all set\n                                     // null. Any of the circle elements can now be initialized.\ncircles[0] = new Circle(5);\ncircles[4] = new Circle(8);\nThe variable name of the array will store the first address of a block of memory cells that have been set aside to store addresses for the objects. Think of it as circles is storing a key, and that key opens a chest of drawers each of which has another key to a circle in another location. Incidentally, this idea of a variable name storing a reference to an array of references is the same way a multidimensional array is dealt with.\nint [][] arr = new int [4][10];       // a 2D array of 4 rows and 10 columns.\narr[2][8] = 103;                     // store the value 103 in the 3rd row and 9th column.\nIn the example above, arr is storing a key. That key opens up a row of drawers. In each of those drawers is another key that opens up a row of drawers where the values are actually kept. In more official terms, arr is a reference to a single dimensional array that contains references. Each of those references gives access to their own single dimensional array of values. So a 2D array is an array of arrays.\n\n\nReferences:\nObject Oriented Data Structures using Java (4th Edition). Nell Dale, Daniel T. Joyce, Chip Weems."
  },
  {
    "objectID": "Chapter0_2.html#memory",
    "href": "Chapter0_2.html#memory",
    "title": "Chapter 0.2",
    "section": "",
    "text": "If the discussion in this section is a bit too difficult for you to understand, please refer to the last Computer Architecture discussion we had in CSC132. Recall that during our discussion of how a computer works, we talked about the makeup of memory. At a very basic level, memory is made up of “words” which is a unit of memory. Each word has a specific address, and is used to store both data and the instructions that work upon that data. The diagram below shows a sample memory space with 256 words."
  },
  {
    "objectID": "Chapter0_2.html#storing-variables",
    "href": "Chapter0_2.html#storing-variables",
    "title": "Chapter 0.2",
    "section": "",
    "text": "The operating system is in charge of mapping variables to addresses and the data stored in that address and there are two main ways that it does this.\nWith direct addressing , the location associated with the variable stores the value of that variable. This is typically the case with primitive data types e.g. characters, int, float, long, etc. The variable is said to be stored by value.\nWith indirect addressing, the location associated with the variable stores the address of another location that has the actual value. Think of it as the memory location is storing the keys of the actual place where the value is stored. This is typically the case with complex data types e.g. strings, objects created from classes, etc. The variable is said to be stored by reference.\n\nchar ch = ‘a’; //direct addressing    \nString str = “dog”;     \n\n/*\nindirect addressing. str has the address 03 and the actual value is found at that address. \nThis consists of the data plus some extra information that could help with some extra manipulation.   \n    \nThis is sometimes represented as    \n\n                str -&gt; dog  \n    \n**spoiler alert: This arrow representation will come back later when we discuss linked lists.*/"
  },
  {
    "objectID": "Chapter0_2.html#what-does-this-mean-for-our-programming",
    "href": "Chapter0_2.html#what-does-this-mean-for-our-programming",
    "title": "Chapter 0.2",
    "section": "",
    "text": "// This is a basic class representing a circle All it stores is the radius. \n// It has a constructor, an accessor and a mutator.\nclass Circle\n{\n    private int radius;\n\n    public Circle(int radius)\n    {\n        setRadius(radius);\n    }\n\n    public void setRadius(int radius)\n    {\n        if (radius&gt;=0)\n            this.radius = radius;\n        else\n            this.radius =1;\n    }\n\n    public int getRadius()\n    {\n        return this.radius;\n    }\n    \n    public String toString()\n    {\n        return \"This circle has a radius of \" + this.getRadius();\n    }\n}\nGiven the Circle class defined above, let’s write some lines of code and see what happens in memory, and how it can be represented diagramatically. We shall also be manipulating a primitive type (int) so that you can notice the contrast between the two.\n// Simple declaration of two variables. \n// One is an object of type Circle and the other is a primitive integer\nCircle a; \nint x;  \n\nNotice that without any initialization, Java will put some default values in those memory locations. For objects, the default value is null to mean the lack of a reference (or address). The default value for ints is 0.\nFYI null can also be used in object comparison\nif (a== null)\n    System.out.println(“Circle has not been initialized”);\n// Assigning initial values to both a and x. \n// For a, this involves creating a circle object and passing it any required  parameters.\n\na = new Circle(5); \nx = 5; \n\nWhile the location associated with x stores the actual value of x (i.e. 5), the location associated with a stores the address of a location in memory (12AB) where the information representing the circle object is actually stored. This means x is stored by value, and a is stored by reference. Declaration and Initialization can also be done in a single step.\nCircle b = new Circle(7);\nint y = 7;\n\nBoth a and b are objects and therefore are stored by reference while x and y which are primitive types are stored by value.\n\n\n\nWhen a primitive type is assigned, the value stored in the location is copied to the new location.\nx = y;      // This copies the value that was in y into x.\na = b;      // This copies the reference stored in b into a\nHowever, when an object is assigned, whatever is stored in the source location is copied into the target location. Recall that an address/reference is actually what is stored and not the actual value. Therefore object assignment has the unique effect of making both variables refer to the same copy of the object instead of having two copies of the object.\n\nThere are a couple of implications of this behavior.\n\nFirstly, the original circle located at 12AB is no longer accessible. The memory location is being used to store the circle, but that circle can no longer be used since there is no way to get to it. The space it takes up is now referred to as garbage. Java automatically cleans garbage(garbage collection) so that the computer/program has access to that memory eventually. This is not the case in other languages.\n\nCircle c;\nfor (int n = 0; n &lt; 100; n++)\n{\n    c = new Circle(n*2); // create a circle with a radius twice the size of n\n}\n/* Notice that when this loop finishes execution, you will only have access to the last\ncreated circle and not the 99 circles before that (which now constitute garbage) */\n\nSecondly, and perhaps more importantly, since a and b refer to the exact same circle (there are two keys to the same house), then any changes made to the copy a (whether intentional or accidental) also affect the original b.\n\n\n\n\nThat last point we discussed might seem very small and avoidable but in reality it isn’t. That’s because whenever an object is passed as a parameter in a function, it is passed by reference. So even if it might have another variable name in the function, any changes to the object will affect the original object.\nclass Test\n{\n    public static void main(String [] args)\n    {\n        Circle a, b, c;\n        a = new Circle(3);\n        b = new Circle(5);\n        c = combinedCircle(a, b);\n        System.out.println(a); // a will have a radius of 10 because it was changed\n        System.out.println(b); // “unintentionally” in the combinedCircle function.\n        System.out.println(c);\n        }\n    public static Circle combinedCircle ( Circle x, Circle y)\n    {\n        Circle z = new Circle(x.getRadius() + y.getRadius());\n        x.setRadius(10);      // statement that changes one of the input arguments, and \n                              // inadvertently changes the original copy in the process.\n        return z;\n    }\n}\n\n\n\nWe have mentioned how primitive types are stored and passed (i.e. by value) and how objects are stored and passed (i.e. by reference). But what about arrays? Recall that with primitive types, the variable name is mapped directly to a memory location that contains the value associated with that variable (by value). Conversely, with objects, the variable name is mapped to a memory location that contains the address of another place in memory where the object state is being stored (by reference). Arrays (of any type) are treated like objects. That means that the array name is mapped to a memory location that contains the address of the first of a block of memory locations that contain the array elements i.e. arrays are passed by reference. This means that if you pass an array as an argument to a function, that function is in fact dealing with the original array and therefore any changes to the array will last even after control has been passed back to the original function.\nimport java.util.*\nclass Trial\n{\n    public static void main(String [] args)\n    {\n        Random r = new Random();\n        int [] arr = new int [100]; // create an array of 100 integers (by default all set to 0)\n        for (int i = 0; i &lt; arr.length; i++)\n        arr[i] = r.nextInt(1000);   // random integer from 0-1000\n        // Sort the array\n        selectionSort(arr); // Note that this function only takes an argument and does not return\n                            // any values. Nonetheless, it is capable of making changes to the \n                            // original array since it has the reference to that array.\n        // Print out the array\n        for (int i = 0; i &lt; arr.length; i++)\n        System.out.print(arr[i] + “ “);\n    }\n    public static void selectionSort(int [] list)\n    {\n        // a sort function that doesn’t have a return type (i.e. void) but actually affects the \n        // variable in the original function. So in an essence it does return something\n    }\n}\nNotice in the example above how the selectionSort function doesn’t have a return type but is still able to affect a variable in the original main function.\n\n\n\nOccasionally, it is necessary to create an array of objects. If objects are mapped by reference, and arrays are mapped by reference, then what about arrays of objects?\nint [] arr = new int [10]; // an array of primitives (for comparison)\nCircle [] circles = new Circle [10];  // an array of circle objects which by default are all set\n                                     // null. Any of the circle elements can now be initialized.\ncircles[0] = new Circle(5);\ncircles[4] = new Circle(8);\nThe variable name of the array will store the first address of a block of memory cells that have been set aside to store addresses for the objects. Think of it as circles is storing a key, and that key opens a chest of drawers each of which has another key to a circle in another location. Incidentally, this idea of a variable name storing a reference to an array of references is the same way a multidimensional array is dealt with.\nint [][] arr = new int [4][10];       // a 2D array of 4 rows and 10 columns.\narr[2][8] = 103;                     // store the value 103 in the 3rd row and 9th column.\nIn the example above, arr is storing a key. That key opens up a row of drawers. In each of those drawers is another key that opens up a row of drawers where the values are actually kept. In more official terms, arr is a reference to a single dimensional array that contains references. Each of those references gives access to their own single dimensional array of values. So a 2D array is an array of arrays.\n\n\nReferences:\nObject Oriented Data Structures using Java (4th Edition). Nell Dale, Daniel T. Joyce, Chip Weems."
  },
  {
    "objectID": "lesson0_1.html",
    "href": "lesson0_1.html",
    "title": "Introduction",
    "section": "",
    "text": "To be in this CSC 220 class, you must have passed the Living With Cyber series taught in CSC 130-132. In that series, you covered the breadth of computer science and learned how to program using Python. At the tail end of CSC 132, you must have also covered some programming in Java. Granted, it might not have been a lot of hands on and you might not be completely comfortable with it, but this class is based on the assumption that you know what it is, and can write some programs using java. Another thing worth mentioning is that this class is a data structures class and NOT a learning how to code in java class. As such the material we’ll cover in class will be mainly about the data structures. However, by the end of the class, you will be expected to be comfortable in programming in Java. In order to bridge this gap, you will have to put in a LOT of extra hours just practicing and learning java on your own. We will spend a few classes at the beginning of the course to cover some of the more unique aspects of java, but the bulk of programming in java is going to be up to you on your own free time. The longer you take to tackle this task, the more detrimental to your assignments this will be. The assignments in this class are more involved and complex than the ones you saw in the Living With Cyber series and will be challenging even for someone who is comfortable with Java. Therefore, take a good amount of time at the beginning of the quarter (first couple of weeks) to get really comfortable with java and the command-line because the assignments will come thick and fast, and you don’t want to get bogged down with java issues when you are trying to solve data structure issues.\nI hope that you are now comfortably scared motivated. Here is a link that you can use to get comfortable with Java. https://runestone.academy/ns/books/published/java4python/Java4Python/toctree.html\nIt is written for a student that is comfortable with python and so I think it will be really useful for you to read through it a couple of times. It shouldn’t take you more than a couple of hours for each read through. Additionally, practice some basic programming in java by attempting some of the assignments you did in Living With Cyber but using java as your language.\n\n\nUsing the terminal can look daunting at first glance but it isn’t as bad as it looks. Unfortunately, like most practical skills one will need to practice using it over and over again before they can become good at using it. The benefits are numerous and being comfortable with the terminal will set you apart from your competition in the work place and in class. After all, every tom, dick, and harry can use an IDE. One of the benefits of using terminal is that combining your code with pre-existing scripts and commands is so easy and allows you to use any terminal or bash tools that are already in existance instead of writing new scripts for the same job. This is particularly important when redirecting input and output from java code which is something you are going to have to do over and over again in this class. The earlier you get comfortable with it, the better for you.\nOther than redirecting output, there are multiple things one can do with terminal and/or bash. https://goo.gl/YzMeBm\nThe link above is to a series of short (a couple of minutes each) tutorials on easy bash tasks that you can learn to do on terminal. They don’t have any direct impact on your java programming but I would highly encourage that you at least take a look at the first few videos and see what I am talking about when I say that you will want to be good at using terminal…and it will take repetition and time. Once you get comfortable with it, you will find that it will be considerably faster than your usual point and click techniques that you are used to and any time you spent watching this videos and trying out some of those commands will be time well spent…trust me. Once you have the latest java jdk installed on your machine, you will have to make sure that it can be compiled and executed from the command line. This is particularly involved with windows machines. Compiling and executing a java file should be automatic with linux machines. Keep track of where (which folder) you installed java on your window system since you will need that information later. Particularly the bin folder. Typically it will be located at  C:\\Program Files\\Java\\jdk1.8.0_31\\bin  This might look different for your own windows computer and so make sure you can find it. You will then need to edit your path variable (under SYSTEM VARIABLES) and add your folder location to it. If done properly, the commands java and javac should return some intelligible information when typed into the terminal. https://goo.gl/dxHUkg\n\n\n\nJava is a formal programming language and one of the most common in use today. Because of that, it is almost impossible to have a career in some form of programming and not use java. It is faster than python (particularly for larger programs) and a lot of the security features it possesses allow you to write programs that will crash less often when run. It is also easy to be used by more than one programmer when a team is working on a project together.\n\n\n\nclass Trial\n{\npublic static void main(String [] args)\n{\nSystem.out.println(“Hello World!”);\n}\n}\n The code above is the java version of the famous hello world program. Before we get bogged down with the differences between java and python, we shall run this program (using terminal). You might recall that java is an interpreted language. This means that running a java program is a two step process i.e. compiling and execution. Compiling allows the computer to convert the java program into a form that is easy to distribute and execute on multiple systems. It also allows the computer to quickly identify potential errors and bring them to your attention before you execute the program. Contrast this with Python which is a scripted language and therefore has to be distributed as the source file. Additionally many of the errors could only be identified during the program execution which one could argue it too late for errors to be found. To compile, navigate to the folder/directory in which the .java file is, and then run the command:  javac filename.java  If there aren’t any syntax errors, then the command above should NOT return any message or output. It should however create a file (Trial.class) whose name depends on the names of the classes in the java files. To execute the program, run the command:  java Trial  This should produce the appropriate/expected output to the terminal. If your java program contained multiple classes, then the compilation would produce multiple class files. To execute your program, you would run the command above using whichever class file contained the “main program.” So now let’s discuss the actual program. Even with something as small as this program, you should be able to notice a few differences from python. First off, everything in Java is in a class. There can’t be a statement, function, etc. that is not in a class. So even for a simple hello world, we have to make a class. Classes, functions, and code blocks in general are delineated by curly braces. They show where the code blocks start and end. In python, such blocks were marked by a uniform indentation. While indentation is HIGHLY encouraged in Java, it is not strictly enforced. Statements in java are ended using a semi-colon. Consider it the full stop or period of the java programming language. Without it, the compiler will assume that the next statement is just a continuation even if there are multiple spaces and or lines between them. The reason for this is that it is common in java to have statements that span multiple lines while that was very infrequent in python.Statements that you want to be executed should be put into functions/methods.You can have any number of functions in the class but there must be a main function. This function can be compared to the conductor of an orchestra. It is the function that the compiler will begin and end its execution with. The main function is in charge of determining which other functions will be executed if any at all. Interestingly, it doesn’t have to be at the top of the class but it being at the top of the class might help with readability of your code. The main program has a specific signature or name i.e.\npublic static void main(String [] args)\nMemorize it because you will be writing it for every single Java program you write."
  },
  {
    "objectID": "lesson0_1.html#using-the-terminal",
    "href": "lesson0_1.html#using-the-terminal",
    "title": "Introduction",
    "section": "",
    "text": "Using the terminal can look daunting at first glance but it isn’t as bad as it looks. Unfortunately, like most practical skills one will need to practice using it over and over again before they can become good at using it. The benefits are numerous and being comfortable with the terminal will set you apart from your competition in the work place and in class. After all, every tom, dick, and harry can use an IDE. One of the benefits of using terminal is that combining your code with pre-existing scripts and commands is so easy and allows you to use any terminal or bash tools that are already in existance instead of writing new scripts for the same job. This is particularly important when redirecting input and output from java code which is something you are going to have to do over and over again in this class. The earlier you get comfortable with it, the better for you.\nOther than redirecting output, there are multiple things one can do with terminal and/or bash. https://goo.gl/YzMeBm\nThe link above is to a series of short (a couple of minutes each) tutorials on easy bash tasks that you can learn to do on terminal. They don’t have any direct impact on your java programming but I would highly encourage that you at least take a look at the first few videos and see what I am talking about when I say that you will want to be good at using terminal…and it will take repetition and time. Once you get comfortable with it, you will find that it will be considerably faster than your usual point and click techniques that you are used to and any time you spent watching this videos and trying out some of those commands will be time well spent…trust me. Once you have the latest java jdk installed on your machine, you will have to make sure that it can be compiled and executed from the command line. This is particularly involved with windows machines. Compiling and executing a java file should be automatic with linux machines. Keep track of where (which folder) you installed java on your window system since you will need that information later. Particularly the bin folder. Typically it will be located at  C:\\Program Files\\Java\\jdk1.8.0_31\\bin  This might look different for your own windows computer and so make sure you can find it. You will then need to edit your path variable (under SYSTEM VARIABLES) and add your folder location to it. If done properly, the commands java and javac should return some intelligible information when typed into the terminal. https://goo.gl/dxHUkg"
  },
  {
    "objectID": "lesson0_1.html#why-java",
    "href": "lesson0_1.html#why-java",
    "title": "Introduction",
    "section": "",
    "text": "Java is a formal programming language and one of the most common in use today. Because of that, it is almost impossible to have a career in some form of programming and not use java. It is faster than python (particularly for larger programs) and a lot of the security features it possesses allow you to write programs that will crash less often when run. It is also easy to be used by more than one programmer when a team is working on a project together."
  },
  {
    "objectID": "lesson0_1.html#our-first-java-programagain.",
    "href": "lesson0_1.html#our-first-java-programagain.",
    "title": "Introduction",
    "section": "",
    "text": "class Trial\n{\npublic static void main(String [] args)\n{\nSystem.out.println(“Hello World!”);\n}\n}\n The code above is the java version of the famous hello world program. Before we get bogged down with the differences between java and python, we shall run this program (using terminal). You might recall that java is an interpreted language. This means that running a java program is a two step process i.e. compiling and execution. Compiling allows the computer to convert the java program into a form that is easy to distribute and execute on multiple systems. It also allows the computer to quickly identify potential errors and bring them to your attention before you execute the program. Contrast this with Python which is a scripted language and therefore has to be distributed as the source file. Additionally many of the errors could only be identified during the program execution which one could argue it too late for errors to be found. To compile, navigate to the folder/directory in which the .java file is, and then run the command:  javac filename.java  If there aren’t any syntax errors, then the command above should NOT return any message or output. It should however create a file (Trial.class) whose name depends on the names of the classes in the java files. To execute the program, run the command:  java Trial  This should produce the appropriate/expected output to the terminal. If your java program contained multiple classes, then the compilation would produce multiple class files. To execute your program, you would run the command above using whichever class file contained the “main program.” So now let’s discuss the actual program. Even with something as small as this program, you should be able to notice a few differences from python. First off, everything in Java is in a class. There can’t be a statement, function, etc. that is not in a class. So even for a simple hello world, we have to make a class. Classes, functions, and code blocks in general are delineated by curly braces. They show where the code blocks start and end. In python, such blocks were marked by a uniform indentation. While indentation is HIGHLY encouraged in Java, it is not strictly enforced. Statements in java are ended using a semi-colon. Consider it the full stop or period of the java programming language. Without it, the compiler will assume that the next statement is just a continuation even if there are multiple spaces and or lines between them. The reason for this is that it is common in java to have statements that span multiple lines while that was very infrequent in python.Statements that you want to be executed should be put into functions/methods.You can have any number of functions in the class but there must be a main function. This function can be compared to the conductor of an orchestra. It is the function that the compiler will begin and end its execution with. The main function is in charge of determining which other functions will be executed if any at all. Interestingly, it doesn’t have to be at the top of the class but it being at the top of the class might help with readability of your code. The main program has a specific signature or name i.e.\npublic static void main(String [] args)\nMemorize it because you will be writing it for every single Java program you write."
  }
]