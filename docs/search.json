[
  {
    "objectID": "lesson1.html",
    "href": "lesson1.html",
    "title": "Introduction to Data Structures & Complexity",
    "section": "",
    "text": "A data structure is a way of storing data in a computer so that it can be used efficiently. In your programming experience so far, you have used some data structures but may not have known that they were data structures. An array is an example of a data structure. The elements are arranged in contiguous memory locations so that they can be accessed, stored, and manipulated quickly. Other types of data structures include sets, unions, records, graphs, trees, etc. Do not confuse data types and data structures. Think of data types as atoms and data structures as molecules. Examples of data types are int, short, long, float, double, char, boolean, etc. So we’ve said that we store data in data structures so that it can be manipulated efficiently, but what exactly does that mean? Manipulation usually means searching, sorting, changing, etc. We normally process some form of input efficiently to generate the “right” output. Data structures allow us to store this data in a way that makes the processing better.\nData structures is essentially what this class is about (as I have mentioned before on many occasions). We will spend the rest of this quarter looking at different commonly used data structures and how we can use them in our code.\n\n1 Complexity\nComputer Scientists are weird people. Whereas the rest of the world is looking at the best times as a measure of effectiveness and excellence, we are looking at the worst time. Usain bolt is celebrated as a runner because he run 100m in 9.58s. In fact, every four years, the whole world stops to watch and celebrate different people demonstrate the best of the best when it comes to physical feats. In computer science, we are more interested in the worst case. This is partly because knowing the worst case allows us to give hard guarantees in our estimates, and prepare for deadlines. After all, the saying is “hope for the best, prepare for the worst.”\nTo represent this “worst case” we use what is referred to as a big-O notation as a measure of how well or poor an algorithm is. This might seem counter intuitive since run time seems the natural unit to measure the performance of an algorithm. However, while run time is a very accurate time measure, it is a very inaccurate algorithm comparison measure. This is because A LOT of factors affect the runtime of an algorithm and many of them have nothing to do with the algorithm itself which is what we are interested in.\nFor example, if I gave you a program to sort some numbers and after executing it, you determined that it took 5 seconds to run. That 5 seconds cannot tell you whether it is better than another sorting program that your colleague executed in 8 seconds. Why? How much of that 5 seconds run time is down to the computer system one is using (faster processor)? Or the programming language that it was coded in? Or the skill level of the programmer? Or the specific state of the list that was to be sorted (since it might take a short time for a list that was already sorted)? Or the size of the list that was sorted? Almost all these factors that affect the runtime have nothing to do with the “goodness” or “badness” of the actual algorithm which is what we are interested in in order to compare it with another algorithm.\nBig-O is the computer scientist’s answer to all these problems. It is inexact by design and it is this feature that typically confuses people who are looking at big-O for the first time. In a bid to ignore all the non- factors we mentioned earlier, big-O describes the performance of an algorithm in terms of a variable (typically n) that represents the size of the problem. In fact, the big-O notation shows how dependent the algorithms runtime would be on the size of the input data. This data could be anything from the size of a string, to the size of an array, to the size of the problem space, to the number of guests, to the number of slices of pizza. This allows us to shed the fine details and divide problems into categories or broad classes based entirely on how they perform as the size of the data is increased.\n\n\n2 Dinner Party\nAs an example, let us consider this scenario [1]. You are preparing to host a dinner party and this task involves a lot of algorithms which we shall discuss and then categorize using their big-O notation (i.e. how they perform as the data size increases).\nThe first task on your to-do list is cleaning your house. This task does not depend on the number of guests that we are inviting to the dinner party (n). It could take either 3 days or 3 hours (depending on the size of your house) but this is of no consequence to a computer scientist. Since this problem does not change its runtime when the number of guests changes, it is referred to as a constant time problem or \\(O(1)\\).Notice that the variable n does not appear in the parentheses because its run time does not depend on n.\nWhen your guests are at the table, another task on your to-do list is to pass the plate of hors d’oeuvres (its a fancy dinner party) around the table. Clearly the amount of time that this task will take will depend directly on the number of guests at the party. If its just 3 people, it should take about half the amount of time as if it was 6 people. And a dinner party of 300 people would take 100 times as long as the 3. This kind of problem is referred to as a linear problem or \\(O(n)\\). Because big-O is inexact, we don’t care about any multiplicative factors. In the context of this example, we don’t care whether the dish has to be passed round twice or once. To big-O, these are both the same i.e. linear because whether you pass the dish around once or twice, the runtime will grow linearly with the number of guests you invite.\nIn fact, adding a constant subtask does not change its big-O. Making an announcement (which is O(1)) before passing round the hors d’oeuvres (O(n)) still remains O(n) because the runtime for the combined task will still be linear with respect to the number of guests invited. Making an announcement and then passing the dish around a table of 10 will still be about half as short as making an announcement and then passing the dish around a table of 20. This ignoring of less important factors is particularly difficult to wrap your mind around when the constant time factor is a big factor. For example, remodeling your kitchen (O(1)) and then passing the dish around is still in the same category as just passing the dish around even though the first one will take significantly longer. They are in the same category because as the size of the data increases (n), they respond in the same way i.e. linearly.\nAnother task could be having every guest hug each other when they arrive. If there are just two guests, only one hug would be required. With 10 guests, 45 hugs would be required. With 50 guests, 1225 hugs. With 100 guests, 4950 guests. It is easy to tell that the runtime of this problem grows at a faster rate than the size of the problem i.e. the number of hugs becomes larger at a faster rate than that at which the number of guests grows. In fact, this problem falls in the polynomial category; more specifically the quadratic kind \\(O(n^2)\\). This means that if the nput data size doubles, the runtime will increase by a factor of 4. Again any multiplicative or smaller factors don’t matter in big-O. For example, if your task involved everyone hugging each other, then passing a dish around the table, as well as a speech at the beginning of the dinner, the whole task would be \\(O(n^2)\\) because of all the subtasks, it is the \\(O(n^2)\\) factor that will dominate the runtime of the algorithm (i.e. it is the task that will grow most significantly as the input data size increases). Recall that big-O is inexact. We are only trying to capture an expression that represents how its runtime will grow with an increasing data size. Imagine that your dinner guests got involved in a game that required you to stand them in order of height for a game. The sorting algorithms you are familiar with from the Living With Cyber series (e.g. bubble sort) would fall into the O(n2) family. Sorting a group of 100 people will take 100 times as long as sorting a group of 10 people even if the size of the group has only increased by a factor of 10.\nSuppose that as dinner host, your roles involve having short conversations with not just everyone individually, but every possible grouping of your guests. For example with 3 guests, A, B and C. You have to have a conversation with A, B, C, AB, AC, BC, and ABC (i.e. 7 conversations). You don’t need to be an introvert to be daunted by such a task because it grows even faster than the quadratic category discussed earlier. With 4 guests (ABCD), you would need to have 15 conversations i.e. A, B, C, D, AB, AC, AD, BC, BD, CD, ABC, ABD, ACD, BCD, and ABCD. Notice how adding a single guest has basically doubled the amount of work you have to do. It would require 31 conversations for 5 guests, and 63 for 6 guests. This category of problems is exponential or \\(O(2^n)\\), and algorithms in this category are typically avoided because their runtimes get very ugly even for relatively small data sizes. You might recall that we discussed the towers of Hanoi in the Living with Cyber series. The best solution to Towers of Hanoi falls in this category.\nOne other task as dinner host could be deciding how to seat all your guests. Perhaps your guests are very particular about how they should be seated, who they seat next to, etc. Figuring out a seating arrangement even with basic limitations might involve enumerating all the different seating possibilities, and then ranking them and choosing the best. For example, with three guests (ABC), they could be sat as ABC, ACB, BAC, BCA, CBA or CAB. This means that with just 3 guests, I have to write out and compare 6 different seating arrangements. With 4 guests (ABCD), they could be arranged as ‘ABCD’, ‘ABDC’, ‘ACBD’, ‘ACDB’, ‘ADBC’, ‘ADCB’, ‘BACD’, ‘BADC’, ‘BCAD’, ‘BCDA’, ‘BDAC’, ‘BDCA’, ‘CABD’, ‘CADB’, ‘CBAD’, ‘CBDA’, ‘CDAB’, ‘CDBA’, ‘DABC’, ‘DACB’, ‘DBAC’, ‘DBCA’, ‘DCAB’, or ‘DCBA’ for a grand total of 24 arrangements. This category is perhaps the worst of the worst and is referred to as factorial or \\(O(n!)\\). This explains why making seating arrangements at weddings is a very stressful and time intensive venture.\nOne last task. Supposed that in the game we mentioned earlier (where your guests are standing in order of height), you have a task of figuring out whom among your guests has a specific height (which is given in units you are unfamiliar with but which your guests are comfortable with). A quick approach (which should also be familiar to you) would be to go to the middle of the line, and ask that guest if he/ she is the height you’re looking for. It should also be easy to determine whether he/she is taller or shorter than the required height, and as a result you will discard half your guest list from possible suspects. This is similar to the binary search algorithm that you are familiar with. As discussed in Living with Cyber, this algorithm belongs in the logarithmic category or \\(O(log_2n)\\). Algorithms in this category typically reduce the size of the data at each step (by half in this case).\nThere is another major category called the quasi-linear / linearithmic or \\(O(nlog_2n)\\). It doesn’t grow as fast as O(n2) but is faster than O(n). There are a few sorting algorithms that fall into this category that we will be discussing later in the course.\nBroadly speaking, those are the main big-O categories. Once you understand them, you should be able to look at different algorithms and determine which group or family they belong to. Sometimes this involves looking at the algorithm itself, and other times it involves looking at a mathematical expression for its runtime, \\(T(n)\\) given in terms of its data size, \\(n\\). Can you describe the order of growth from these functions using the big-O notation?\n\\[n^3 +2n\\] \\[2n^3 + n^2\\] \\[n+2nlog(n)\\] \\[3n +2n^7\\] \\[n(n+3)/2\\] \\[6\\] \\[1+n^2 +2n^3+3n^4+2^n\\] \\[n^3+2n log(n)\\]\n\n\n\n\n\n\nNote\n\n\n\nRemember the trick is to pick the dominant term and ignore the constants. Basically which term will get out of hand as n increases to really large values?\n\n\n\n\n3 Starting with the algorithm\nKeeping with food, let’s look at a few algorithms you must have used at some point in your lives [2].\npublic donut takeDonut(donut [] box)\n{\n    return box[0]; //return the donut in the first position of donut box\n}\nWhat complexity do you think the algorithm above demonstrates? Does it depend on the number of donuts in the box?\npublic void eatFries(fries [] box)\n{\n    for(int i = 0; i &lt; box.length; i++)\n    {\n        //dip chip in ketchup\n        //eat fry\n    }\n}\nWhat about the complexity of the algorithm above? What kind of relationship is there between its runtime and the number of fries in the box?\n// Every guest comes with a different kind of food   to a potluck i.e. number\n// of guests is the same as the types of food\n\npublic void divideFood(ArrayList&lt;Food&gt;potluck)\n{\n    // for each dish in the potluck\n    for (Food dish : potluck)\n    {\n        // divide food into proper portion sizes based on guest list size.\n        for (int j = 0; j &lt; potluck.size(); j++)\n        {\n            // cut up the food\n        }\n    }\n}\nWhat about the algorithm above? Cutting up the food grows as the amount of food in the potluck grows? Does it grow in a linear fashion or not? Play through the scenario in your head to see if you can recognize the pattern. Two people, everything is cut into two pieces (for a total of 4 portions). Three people, everything is cut into three pieces (for a total of 9 portions). Four people, four pieces each (16 total portions).\nFor simple algorithms, you might be able to simply look at the algorithm and determine what its complexity is. However, more often that not you will need to carry out what is referred to as a Time analysis. It involves identifying the parts of the algorithm where repetition is carried out (since repetition is the main factor that would affect runtime especially as the input size increases) and then writing out a mathematical expression (T(n)) that describes how long a basic statement in that loop would be executed. Once the T(n) expression has been completed, determining the O() is just a matter of identifying the most dominant term in the expression and ignoring any constants. Let’s look at a few examples of code and see if we can deduce their complexities.\nfor (int k=0; k&lt;n; k++)\n{\n    ...      // How many times will this statement be executed?\n}\nAny line in the \\(for\\) loop above will be executed n times. Therefore \\(T(n) = c*n\\) and its complexity is O(n). The constant term c is a multiplier we use to define how long the statements in the loop would take to execute in a single iteration. What about the one below.\nfor (int k=0; k&lt;n; k++)\n{\n    ...     // How many times will this statement be executed?\n    for (int j=0; j&lt;n; j++)\n    {\n        ...    //What about this statement?\n    }\n}\n\\(T(n) = cn^2 + dn\\) which means it is \\(O(n^2)\\).\nThose were fairly straight forward. What about these ones?\nfor (k=0; k&lt;n/2; k++)\n{ \n    ...  // This statement occurs n/2 times\n    for (j=0; j&lt;n*n; j++)\n    {\n        ...  //This statement occurs n*n*n/2 = n^3/2 times\n    }\n}\n\\(T(n) = (cn^3 +dn)/2\\) which means it is \\(O(n^3)\\).\nfor (k=0; k&lt;n/2; k++)\n{\n    ...  // This statement occurs n/2 times\n}\nfor (j=0; j&lt;n*n; j++)\n{\n    ...  //This statement occurs n*n = n^2 times\n}\n\\(T(n) = cn^2 +(dn)/2\\) which means it is \\(O(n^2)\\).\nk = n;\nwhile (k &gt; 1)\n{\n    ...\n    k /= 2;  //integer division - log2n\n}\n\\(T(n) = c*log_2n\\) which means it is \\(O(log_2n)\\).\n\\(log_2n\\) implies division by 2.\n\\(log_3n\\) implies division by 3.\n\\(log_4n\\) implies division by 4…and so on.\n\n\nSometimes calculating the actual number of steps from the T(n) expression will give you an idea of what the dominant term is based on how fast it grows with an increasing n. For example, suppose the time T (number of steps) it takes for a hypothetical algorithm to complete a problem of size n is given by the expression \\[T(n) = 4n^2 – 2n + 2\\] Then we know that if our size is 1, it will take \\[T(1) = 4 – 2 + 2 = 4 steps\\] If our size is 10, it will take \\[T(10) = (4 * 10^2) – (2 * 10) + 2 = 382 steps\\] If our size is 100, it will take \\[T(100) = (4 * 100^2) – (2 * 100) + 2 = 39802 steps\\] and if our size is 1000, it will take \\[T(1000) = (4 * 1000^2) – (2 * 1000) + 2 = 3999802 steps\\]\nYou will have noticed that while our input was only increasing by a factor of 10, the number of steps was increasing by a factor of 100…ish. This is because the dominant term of T(n) is \\(n^2\\) and so we can describe the complexity of this hypothetical algorithm as being \\(O(n^2)\\).\nOnce we have the big-O notation, it can then be used to provide an estimate (admittedly a very poor estimate) of the amount of time (or number of steps) that an algorithm would require for a given data size and then compare it with other algorithms without actually taking the time to implement either algorithm in code. For example given \\(O(n^2)\\) where n is 1000, the algorithm would take approximately: \\[O(1000) ≈ 1000^2 = 1000000 steps\\]\nThe number of steps can then later be translated to time if you know how long the average step would take on a specific system.\nBelow is a table showing the most common big-O categories and some common examples of algorithms in those categories [3].\n\n\n\n\n\n\n\n\nBig-O\nName\nExamples\n\n\n\n\n\\(O(1)\\)\nconstant\n\nAccessing an element in an array given its index e.g. Getting the first element of a list\nChecking if a number is even or odd\n\n\n\n\\(O(logn)\\)\nlogarithmic\n\ncures scurvy\ntasty\n\n\n\n\\(O(n)\\)\nlinear\n\nLinear search eg.finding the maximum element in a list\n\n\n\n\\(O(nlogn)\\)\nquasi-linear\n\nAdvanced sorting algorithms e.g. mergesort\n\n\n\n\\(O(n^2)\\)\nQuadratic\n\nBasic sorting algorithms e.g. bubblesort\nSearching for duplicates in a list*\nDealing with a two dimensional array\n\n\n\n\\(O(n^3)\\)\nCubic\n\nDealing with a three dimensional array\nSolving a three variable equation\n\n\n\n\\(O(2^n)\\)\nExponential\n\nFinding all subsets of a data collection\nTowers of Hanoi\n\n\n\n\\(O(n!)\\)\nFactorial\n\nFinding all permutations of a given data collection e.g. figuring out a password given all the characters of the password.\n\n\n\n\nJust a few last tips on identifying the dominant term from an expression.\n\nn dominates \\(log_bn\\) (b is often 2)\n\n\\(nlog_bn\\) dominates n\n\\(n^m\\) dominates \\(n^k\\) when m&gt;k\n\\(a^n\\) dominates \\(n^m\\) for any values of a and m greater than 1.\n\n  Ref: Algorithms to Live By, by Brian Christian and Tom Griffiths https://vickylai.com/verbose/a-coffee-break-introduction-to-time-complexity-of-algorithms/ https://adrianmejia.com/blog/2018/04/05/most-popular-algorithms-time-complexity-every-programmer-should-know-free-online-tutorial-course/ Object Oriented Data Structures using Java (4th Edition). Nell Dale, Daniel T. Joyce, Chip Weems."
  },
  {
    "objectID": "lesson0_2.html",
    "href": "lesson0_2.html",
    "title": "Chapter 0.2",
    "section": "",
    "text": "If the discussion in this section is a bit too difficult for you to understand, please refer to the last Computer Architecture discussion we had in CSC132. Recall that during our discussion of how a computer works, we talked about the makeup of memory. At a very basic level, memory is made up of “words” which is a unit of memory. Each word has a specific address, and is used to store both data and the instructions that work upon that data. The diagram below shows a sample memory space with 256 words.\n \n\n\n\n\nThe operating system is in charge of mapping variables to addresses and the data stored in that address and there are two main ways that it does this.\nWith direct addressing , the location associated with the variable stores the value of that variable. This is typically the case with primitive data types e.g. characters, int, float, long, etc. The variable is said to be stored by value.\nWith indirect addressing, the location associated with the variable stores the address of another location that has the actual value. Think of it as the memory location is storing the keys of the actual place where the value is stored. This is typically the case with complex data types e.g. strings, objects created from classes, etc. The variable is said to be stored by reference.\n\nchar ch = ‘a’; //direct addressing    \nString str = “dog”;     \n\n/*\nindirect addressing. str has the address 03 and the actual value is found at that address. \nThis consists of the data plus some extra information that could help with some extra manipulation.   \n    \nThis is sometimes represented as    \n\n                str -&gt; dog  \n    \n**spoiler alert: This arrow representation will come back later when we discuss linked lists.*/\n\n\n\n\n\n// This is a basic class representing a circle All it stores is the radius. \n// It has a constructor, an accessor and a mutator.\nclass Circle\n{\n    private int radius;\n\n    public Circle(int radius)\n    {\n        setRadius(radius);\n    }\n\n    public void setRadius(int radius)\n    {\n        if (radius&gt;=0)\n            this.radius = radius;\n        else\n            this.radius =1;\n    }\n\n    public int getRadius()\n    {\n        return this.radius;\n    }\n    \n    public String toString()\n    {\n        return \"This circle has a radius of \" + this.getRadius();\n    }\n}\nGiven the Circle class defined above, let’s write some lines of code and see what happens in memory, and how it can be represented diagramatically. We shall also be manipulating a primitive type (int) so that you can notice the contrast between the two.\n// Simple declaration of two variables. \n// One is an object of type Circle and the other is a primitive integer\nCircle a; \nint x;  \n\nNotice that without any initialization, Java will put some default values in those memory locations. For objects, the default value is null to mean the lack of a reference (or address). The default value for ints is 0.\nFYI null can also be used in object comparison\nif (a== null)\n    System.out.println(“Circle has not been initialized”);\n// Assigning initial values to both a and x. \n// For a, this involves creating a circle object and passing it any required  parameters.\n\na = new Circle(5); \nx = 5; \n\nWhile the location associated with x stores the actual value of x (i.e. 5), the location associated with a stores the address of a location in memory (12AB) where the information representing the circle object is actually stored. This means x is stored by value, and a is stored by reference. Declaration and Initialization can also be done in a single step.\nCircle b = new Circle(7);\nint y = 7;\n\nBoth a and b are objects and therefore are stored by reference while x and y which are primitive types are stored by value.\n\n\n\nWhen a primitive type is assigned, the value stored in the location is copied to the new location.\nx = y;      // This copies the value that was in y into x.\na = b;      // This copies the reference stored in b into a\nHowever, when an object is assigned, whatever is stored in the source location is copied into the target location. Recall that an address/reference is actually what is stored and not the actual value. Therefore object assignment has the unique effect of making both variables refer to the same copy of the object instead of having two copies of the object.\n\nThere are a couple of implications of this behavior.\n\nFirstly, the original circle located at 12AB is no longer accessible. The memory location is being used to store the circle, but that circle can no longer be used since there is no way to get to it. The space it takes up is now referred to as garbage. Java automatically cleans garbage(garbage collection) so that the computer/program has access to that memory eventually. This is not the case in other languages.\n\nCircle c;\nfor (int n = 0; n &lt; 100; n++)\n{\n    c = new Circle(n*2); // create a circle with a radius twice the size of n\n}\n/* Notice that when this loop finishes execution, you will only have access to the last\ncreated circle and not the 99 circles before that (which now constitute garbage) */\n\nSecondly, and perhaps more importantly, since a and b refer to the exact same circle (there are two keys to the same house), then any changes made to the copy a (whether intentional or accidental) also affect the original b.\n\n\n\n\nThat last point we discussed might seem very small and avoidable but in reality it isn’t. That’s because whenever an object is passed as a parameter in a function, it is passed by reference. So even if it might have another variable name in the function, any changes to the object will affect the original object.\nclass Test\n{\n    public static void main(String [] args)\n    {\n        Circle a, b, c;\n        a = new Circle(3);\n        b = new Circle(5);\n        c = combinedCircle(a, b);\n        System.out.println(a); // a will have a radius of 10 because it was changed\n        System.out.println(b); // “unintentionally” in the combinedCircle function.\n        System.out.println(c);\n        }\n    public static Circle combinedCircle ( Circle x, Circle y)\n    {\n        Circle z = new Circle(x.getRadius() + y.getRadius());\n        x.setRadius(10);      // statement that changes one of the input arguments, and \n                              // inadvertently changes the original copy in the process.\n        return z;\n    }\n}\n\n\n\nWe have mentioned how primitive types are stored and passed (i.e. by value) and how objects are stored and passed (i.e. by reference). But what about arrays? Recall that with primitive types, the variable name is mapped directly to a memory location that contains the value associated with that variable (by value). Conversely, with objects, the variable name is mapped to a memory location that contains the address of another place in memory where the object state is being stored (by reference). Arrays (of any type) are treated like objects. That means that the array name is mapped to a memory location that contains the address of the first of a block of memory locations that contain the array elements i.e. arrays are passed by reference. This means that if you pass an array as an argument to a function, that function is in fact dealing with the original array and therefore any changes to the array will last even after control has been passed back to the original function.\nimport java.util.*\nclass Trial\n{\n    public static void main(String [] args)\n    {\n        Random r = new Random();\n        int [] arr = new int [100]; // create an array of 100 integers (by default all set to 0)\n        for (int i = 0; i &lt; arr.length; i++)\n        arr[i] = r.nextInt(1000);   // random integer from 0-1000\n        // Sort the array\n        selectionSort(arr); // Note that this function only takes an argument and does not return\n                            // any values. Nonetheless, it is capable of making changes to the \n                            // original array since it has the reference to that array.\n        // Print out the array\n        for (int i = 0; i &lt; arr.length; i++)\n        System.out.print(arr[i] + “ “);\n    }\n    public static void selectionSort(int [] list)\n    {\n        // a sort function that doesn’t have a return type (i.e. void) but actually affects the \n        // variable in the original function. So in an essence it does return something\n    }\n}\nNotice in the example above how the selectionSort function doesn’t have a return type but is still able to affect a variable in the original main function.\n\n\n\nOccasionally, it is necessary to create an array of objects. If objects are mapped by reference, and arrays are mapped by reference, then what about arrays of objects?\nint [] arr = new int [10]; // an array of primitives (for comparison)\nCircle [] circles = new Circle [10];  // an array of circle objects which by default are all set\n                                     // null. Any of the circle elements can now be initialized.\ncircles[0] = new Circle(5);\ncircles[4] = new Circle(8);\nThe variable name of the array will store the first address of a block of memory cells that have been set aside to store addresses for the objects. Think of it as circles is storing a key, and that key opens a chest of drawers each of which has another key to a circle in another location. Incidentally, this idea of a variable name storing a reference to an array of references is the same way a multidimensional array is dealt with.\nint [][] arr = new int [4][10];       // a 2D array of 4 rows and 10 columns.\narr[2][8] = 103;                     // store the value 103 in the 3rd row and 9th column.\nIn the example above, arr is storing a key. That key opens up a row of drawers. In each of those drawers is another key that opens up a row of drawers where the values are actually kept. In more official terms, arr is a reference to a single dimensional array that contains references. Each of those references gives access to their own single dimensional array of values. So a 2D array is an array of arrays.\n\n\nReferences:\nObject Oriented Data Structures using Java (4th Edition). Nell Dale, Daniel T. Joyce, Chip Weems."
  },
  {
    "objectID": "lesson0_2.html#memory",
    "href": "lesson0_2.html#memory",
    "title": "Chapter 0.2",
    "section": "",
    "text": "If the discussion in this section is a bit too difficult for you to understand, please refer to the last Computer Architecture discussion we had in CSC132. Recall that during our discussion of how a computer works, we talked about the makeup of memory. At a very basic level, memory is made up of “words” which is a unit of memory. Each word has a specific address, and is used to store both data and the instructions that work upon that data. The diagram below shows a sample memory space with 256 words."
  },
  {
    "objectID": "lesson0_2.html#storing-variables",
    "href": "lesson0_2.html#storing-variables",
    "title": "Chapter 0.2",
    "section": "",
    "text": "The operating system is in charge of mapping variables to addresses and the data stored in that address and there are two main ways that it does this.\nWith direct addressing , the location associated with the variable stores the value of that variable. This is typically the case with primitive data types e.g. characters, int, float, long, etc. The variable is said to be stored by value.\nWith indirect addressing, the location associated with the variable stores the address of another location that has the actual value. Think of it as the memory location is storing the keys of the actual place where the value is stored. This is typically the case with complex data types e.g. strings, objects created from classes, etc. The variable is said to be stored by reference.\n\nchar ch = ‘a’; //direct addressing    \nString str = “dog”;     \n\n/*\nindirect addressing. str has the address 03 and the actual value is found at that address. \nThis consists of the data plus some extra information that could help with some extra manipulation.   \n    \nThis is sometimes represented as    \n\n                str -&gt; dog  \n    \n**spoiler alert: This arrow representation will come back later when we discuss linked lists.*/"
  },
  {
    "objectID": "lesson0_2.html#what-does-this-mean-for-our-programming",
    "href": "lesson0_2.html#what-does-this-mean-for-our-programming",
    "title": "Chapter 0.2",
    "section": "",
    "text": "// This is a basic class representing a circle All it stores is the radius. \n// It has a constructor, an accessor and a mutator.\nclass Circle\n{\n    private int radius;\n\n    public Circle(int radius)\n    {\n        setRadius(radius);\n    }\n\n    public void setRadius(int radius)\n    {\n        if (radius&gt;=0)\n            this.radius = radius;\n        else\n            this.radius =1;\n    }\n\n    public int getRadius()\n    {\n        return this.radius;\n    }\n    \n    public String toString()\n    {\n        return \"This circle has a radius of \" + this.getRadius();\n    }\n}\nGiven the Circle class defined above, let’s write some lines of code and see what happens in memory, and how it can be represented diagramatically. We shall also be manipulating a primitive type (int) so that you can notice the contrast between the two.\n// Simple declaration of two variables. \n// One is an object of type Circle and the other is a primitive integer\nCircle a; \nint x;  \n\nNotice that without any initialization, Java will put some default values in those memory locations. For objects, the default value is null to mean the lack of a reference (or address). The default value for ints is 0.\nFYI null can also be used in object comparison\nif (a== null)\n    System.out.println(“Circle has not been initialized”);\n// Assigning initial values to both a and x. \n// For a, this involves creating a circle object and passing it any required  parameters.\n\na = new Circle(5); \nx = 5; \n\nWhile the location associated with x stores the actual value of x (i.e. 5), the location associated with a stores the address of a location in memory (12AB) where the information representing the circle object is actually stored. This means x is stored by value, and a is stored by reference. Declaration and Initialization can also be done in a single step.\nCircle b = new Circle(7);\nint y = 7;\n\nBoth a and b are objects and therefore are stored by reference while x and y which are primitive types are stored by value.\n\n\n\nWhen a primitive type is assigned, the value stored in the location is copied to the new location.\nx = y;      // This copies the value that was in y into x.\na = b;      // This copies the reference stored in b into a\nHowever, when an object is assigned, whatever is stored in the source location is copied into the target location. Recall that an address/reference is actually what is stored and not the actual value. Therefore object assignment has the unique effect of making both variables refer to the same copy of the object instead of having two copies of the object.\n\nThere are a couple of implications of this behavior.\n\nFirstly, the original circle located at 12AB is no longer accessible. The memory location is being used to store the circle, but that circle can no longer be used since there is no way to get to it. The space it takes up is now referred to as garbage. Java automatically cleans garbage(garbage collection) so that the computer/program has access to that memory eventually. This is not the case in other languages.\n\nCircle c;\nfor (int n = 0; n &lt; 100; n++)\n{\n    c = new Circle(n*2); // create a circle with a radius twice the size of n\n}\n/* Notice that when this loop finishes execution, you will only have access to the last\ncreated circle and not the 99 circles before that (which now constitute garbage) */\n\nSecondly, and perhaps more importantly, since a and b refer to the exact same circle (there are two keys to the same house), then any changes made to the copy a (whether intentional or accidental) also affect the original b.\n\n\n\n\nThat last point we discussed might seem very small and avoidable but in reality it isn’t. That’s because whenever an object is passed as a parameter in a function, it is passed by reference. So even if it might have another variable name in the function, any changes to the object will affect the original object.\nclass Test\n{\n    public static void main(String [] args)\n    {\n        Circle a, b, c;\n        a = new Circle(3);\n        b = new Circle(5);\n        c = combinedCircle(a, b);\n        System.out.println(a); // a will have a radius of 10 because it was changed\n        System.out.println(b); // “unintentionally” in the combinedCircle function.\n        System.out.println(c);\n        }\n    public static Circle combinedCircle ( Circle x, Circle y)\n    {\n        Circle z = new Circle(x.getRadius() + y.getRadius());\n        x.setRadius(10);      // statement that changes one of the input arguments, and \n                              // inadvertently changes the original copy in the process.\n        return z;\n    }\n}\n\n\n\nWe have mentioned how primitive types are stored and passed (i.e. by value) and how objects are stored and passed (i.e. by reference). But what about arrays? Recall that with primitive types, the variable name is mapped directly to a memory location that contains the value associated with that variable (by value). Conversely, with objects, the variable name is mapped to a memory location that contains the address of another place in memory where the object state is being stored (by reference). Arrays (of any type) are treated like objects. That means that the array name is mapped to a memory location that contains the address of the first of a block of memory locations that contain the array elements i.e. arrays are passed by reference. This means that if you pass an array as an argument to a function, that function is in fact dealing with the original array and therefore any changes to the array will last even after control has been passed back to the original function.\nimport java.util.*\nclass Trial\n{\n    public static void main(String [] args)\n    {\n        Random r = new Random();\n        int [] arr = new int [100]; // create an array of 100 integers (by default all set to 0)\n        for (int i = 0; i &lt; arr.length; i++)\n        arr[i] = r.nextInt(1000);   // random integer from 0-1000\n        // Sort the array\n        selectionSort(arr); // Note that this function only takes an argument and does not return\n                            // any values. Nonetheless, it is capable of making changes to the \n                            // original array since it has the reference to that array.\n        // Print out the array\n        for (int i = 0; i &lt; arr.length; i++)\n        System.out.print(arr[i] + “ “);\n    }\n    public static void selectionSort(int [] list)\n    {\n        // a sort function that doesn’t have a return type (i.e. void) but actually affects the \n        // variable in the original function. So in an essence it does return something\n    }\n}\nNotice in the example above how the selectionSort function doesn’t have a return type but is still able to affect a variable in the original main function.\n\n\n\nOccasionally, it is necessary to create an array of objects. If objects are mapped by reference, and arrays are mapped by reference, then what about arrays of objects?\nint [] arr = new int [10]; // an array of primitives (for comparison)\nCircle [] circles = new Circle [10];  // an array of circle objects which by default are all set\n                                     // null. Any of the circle elements can now be initialized.\ncircles[0] = new Circle(5);\ncircles[4] = new Circle(8);\nThe variable name of the array will store the first address of a block of memory cells that have been set aside to store addresses for the objects. Think of it as circles is storing a key, and that key opens a chest of drawers each of which has another key to a circle in another location. Incidentally, this idea of a variable name storing a reference to an array of references is the same way a multidimensional array is dealt with.\nint [][] arr = new int [4][10];       // a 2D array of 4 rows and 10 columns.\narr[2][8] = 103;                     // store the value 103 in the 3rd row and 9th column.\nIn the example above, arr is storing a key. That key opens up a row of drawers. In each of those drawers is another key that opens up a row of drawers where the values are actually kept. In more official terms, arr is a reference to a single dimensional array that contains references. Each of those references gives access to their own single dimensional array of values. So a 2D array is an array of arrays.\n\n\nReferences:\nObject Oriented Data Structures using Java (4th Edition). Nell Dale, Daniel T. Joyce, Chip Weems."
  },
  {
    "objectID": "lesson0_1.html",
    "href": "lesson0_1.html",
    "title": "Introduction",
    "section": "",
    "text": "To be in this CSC 220 class, you must have passed the Living With Cyber series taught in CSC 130-132. In that series, you covered the breadth of computer science and learned how to program using Python. At the tail end of CSC 132, you must have also covered some programming in Java. Granted, it might not have been a lot of hands on and you might not be completely comfortable with it, but this class is based on the assumption that you know what it is, and can write some programs using java. Another thing worth mentioning is that this class is a data structures class and NOT a learning how to code in java class. As such the material we’ll cover in class will be mainly about the data structures. However, by the end of the class, you will be expected to be comfortable in programming in Java. In order to bridge this gap, you will have to put in a LOT of extra hours just practicing and learning java on your own. We will spend a few classes at the beginning of the course to cover some of the more unique aspects of java, but the bulk of programming in java is going to be up to you on your own free time. The longer you take to tackle this task, the more detrimental to your assignments this will be. The assignments in this class are more involved and complex than the ones you saw in the Living With Cyber series and will be challenging even for someone who is comfortable with Java. Therefore, take a good amount of time at the beginning of the quarter (first couple of weeks) to get really comfortable with java and the command-line because the assignments will come thick and fast, and you don’t want to get bogged down with java issues when you are trying to solve data structure issues.\nI hope that you are now comfortably scared motivated. Here is a link that you can use to get comfortable with Java. https://runestone.academy/ns/books/published/java4python/Java4Python/toctree.html\nIt is written for a student that is comfortable with python and so I think it will be really useful for you to read through it a couple of times. It shouldn’t take you more than a couple of hours for each read through. Additionally, practice some basic programming in java by attempting some of the assignments you did in Living With Cyber but using java as your language.\n\n\nUsing the terminal can look daunting at first glance but it isn’t as bad as it looks. Unfortunately, like most practical skills one will need to practice using it over and over again before they can become good at using it. The benefits are numerous and being comfortable with the terminal will set you apart from your competition in the work place and in class. After all, every tom, dick, and harry can use an IDE. One of the benefits of using terminal is that combining your code with pre-existing scripts and commands is so easy and allows you to use any terminal or bash tools that are already in existance instead of writing new scripts for the same job. This is particularly important when redirecting input and output from java code which is something you are going to have to do over and over again in this class. The earlier you get comfortable with it, the better for you.\nOther than redirecting output, there are multiple things one can do with terminal and/or bash. https://goo.gl/YzMeBm\nThe link above is to a series of short (a couple of minutes each) tutorials on easy bash tasks that you can learn to do on terminal. They don’t have any direct impact on your java programming but I would highly encourage that you at least take a look at the first few videos and see what I am talking about when I say that you will want to be good at using terminal…and it will take repetition and time. Once you get comfortable with it, you will find that it will be considerably faster than your usual point and click techniques that you are used to and any time you spent watching this videos and trying out some of those commands will be time well spent…trust me. Once you have the latest java jdk installed on your machine, you will have to make sure that it can be compiled and executed from the command line. This is particularly involved with windows machines. Compiling and executing a java file should be automatic with linux machines. Keep track of where (which folder) you installed java on your window system since you will need that information later. Particularly the bin folder. Typically it will be located at  C:\\Program Files\\Java\\jdk1.8.0_31\\bin  This might look different for your own windows computer and so make sure you can find it. You will then need to edit your path variable (under SYSTEM VARIABLES) and add your folder location to it. If done properly, the commands java and javac should return some intelligible information when typed into the terminal. https://goo.gl/dxHUkg\n\n\n\nJava is a formal programming language and one of the most common in use today. Because of that, it is almost impossible to have a career in some form of programming and not use java. It is faster than python (particularly for larger programs) and a lot of the security features it possesses allow you to write programs that will crash less often when run. It is also easy to be used by more than one programmer when a team is working on a project together.\n\n\n\nclass Trial\n{\n   public static void main(String [] args)\n   {\n      System.out.println(“Hello World!”);\n   }\n}\n The code above is the java version of the famous hello world program. Before we get bogged down with the differences between java and python, we shall run this program (using terminal). You might recall that java is an interpreted language. This means that running ajava program is a two step process i.e. compiling and execution. Compiling allows the computer to convert the java program into a form that is easy to distribute and execute on multiple systems. It also allows the computer to quickly identify potential errors and bring them to your attention before you execute the program. Contrast this with Python which is a scripted language and therefore has to be distributed as the source file. Additionally many of the errors could only be identified during the program execution which one could argue it too late for errors to be found. To compile, navigate to the folder/directory in which the .java file is, and then run the command:  javac filename.java  If there aren’t any syntax errors, then the command above should NOT return any message or output. It should however create a file (Trial.class) whose name depends on the names of the classes in the java files. To execute the program, run the command:  java Trial  This should produce the appropriate/expected output to the terminal. If your java program contained multiple classes, then the compilation would produce multiple class files. To execute your program, you would run the command above using whichever class file contained the “main program.” So now let’s discuss the actual program. Even with something as small as this program, you should be able to notice a few differences from python. First off, everything in Java is in a class. There can’t be a statement, function, etc. that is not in a class. So even for a simple hello world, we have to make a class. Classes, functions, and code blocks in general are delineated by curly braces. They show where the code blocks start and end. In python, such blocks were marked by a uniform indentation. While indentation is HIGHLY encouraged in Java, it is not strictly enforced. Statements in java are ended using a semi-colon. Consider it the full stop or period of the java programming language. Without it, the compiler will assume that the next statement is just a continuation even if there are multiple spaces and or lines between them. The reason for this is that it is common in java to have statements that span multiple lines while that was very infrequent in python.Statements that you want to be executed should be put into functions/methods.You can have any number of functions in the class but there must be a main function. This function can be compared to the conductor of an orchestra. It is the function that the compiler will begin and end its execution with. The main function is in charge of determining which other functions will be executed if any at all. Interestingly, it doesn’t have to be at the top of the class but it being at the top of the class might help with readability of your code. The main program has a specific signature or name i.e.\npublic static void main(String [] args)\n\n\n\n\n\n\nNote\n\n\n\nMemorize it because you will be writing it for every single Java program you write."
  },
  {
    "objectID": "lesson0_1.html#using-the-terminal",
    "href": "lesson0_1.html#using-the-terminal",
    "title": "Introduction",
    "section": "",
    "text": "Using the terminal can look daunting at first glance but it isn’t as bad as it looks. Unfortunately, like most practical skills one will need to practice using it over and over again before they can become good at using it. The benefits are numerous and being comfortable with the terminal will set you apart from your competition in the work place and in class. After all, every tom, dick, and harry can use an IDE. One of the benefits of using terminal is that combining your code with pre-existing scripts and commands is so easy and allows you to use any terminal or bash tools that are already in existance instead of writing new scripts for the same job. This is particularly important when redirecting input and output from java code which is something you are going to have to do over and over again in this class. The earlier you get comfortable with it, the better for you.\nOther than redirecting output, there are multiple things one can do with terminal and/or bash. https://goo.gl/YzMeBm\nThe link above is to a series of short (a couple of minutes each) tutorials on easy bash tasks that you can learn to do on terminal. They don’t have any direct impact on your java programming but I would highly encourage that you at least take a look at the first few videos and see what I am talking about when I say that you will want to be good at using terminal…and it will take repetition and time. Once you get comfortable with it, you will find that it will be considerably faster than your usual point and click techniques that you are used to and any time you spent watching this videos and trying out some of those commands will be time well spent…trust me. Once you have the latest java jdk installed on your machine, you will have to make sure that it can be compiled and executed from the command line. This is particularly involved with windows machines. Compiling and executing a java file should be automatic with linux machines. Keep track of where (which folder) you installed java on your window system since you will need that information later. Particularly the bin folder. Typically it will be located at  C:\\Program Files\\Java\\jdk1.8.0_31\\bin  This might look different for your own windows computer and so make sure you can find it. You will then need to edit your path variable (under SYSTEM VARIABLES) and add your folder location to it. If done properly, the commands java and javac should return some intelligible information when typed into the terminal. https://goo.gl/dxHUkg"
  },
  {
    "objectID": "lesson0_1.html#why-java",
    "href": "lesson0_1.html#why-java",
    "title": "Introduction",
    "section": "",
    "text": "Java is a formal programming language and one of the most common in use today. Because of that, it is almost impossible to have a career in some form of programming and not use java. It is faster than python (particularly for larger programs) and a lot of the security features it possesses allow you to write programs that will crash less often when run. It is also easy to be used by more than one programmer when a team is working on a project together."
  },
  {
    "objectID": "lesson0_1.html#our-first-java-programagain.",
    "href": "lesson0_1.html#our-first-java-programagain.",
    "title": "Introduction",
    "section": "",
    "text": "class Trial\n{\n   public static void main(String [] args)\n   {\n      System.out.println(“Hello World!”);\n   }\n}\n The code above is the java version of the famous hello world program. Before we get bogged down with the differences between java and python, we shall run this program (using terminal). You might recall that java is an interpreted language. This means that running ajava program is a two step process i.e. compiling and execution. Compiling allows the computer to convert the java program into a form that is easy to distribute and execute on multiple systems. It also allows the computer to quickly identify potential errors and bring them to your attention before you execute the program. Contrast this with Python which is a scripted language and therefore has to be distributed as the source file. Additionally many of the errors could only be identified during the program execution which one could argue it too late for errors to be found. To compile, navigate to the folder/directory in which the .java file is, and then run the command:  javac filename.java  If there aren’t any syntax errors, then the command above should NOT return any message or output. It should however create a file (Trial.class) whose name depends on the names of the classes in the java files. To execute the program, run the command:  java Trial  This should produce the appropriate/expected output to the terminal. If your java program contained multiple classes, then the compilation would produce multiple class files. To execute your program, you would run the command above using whichever class file contained the “main program.” So now let’s discuss the actual program. Even with something as small as this program, you should be able to notice a few differences from python. First off, everything in Java is in a class. There can’t be a statement, function, etc. that is not in a class. So even for a simple hello world, we have to make a class. Classes, functions, and code blocks in general are delineated by curly braces. They show where the code blocks start and end. In python, such blocks were marked by a uniform indentation. While indentation is HIGHLY encouraged in Java, it is not strictly enforced. Statements in java are ended using a semi-colon. Consider it the full stop or period of the java programming language. Without it, the compiler will assume that the next statement is just a continuation even if there are multiple spaces and or lines between them. The reason for this is that it is common in java to have statements that span multiple lines while that was very infrequent in python.Statements that you want to be executed should be put into functions/methods.You can have any number of functions in the class but there must be a main function. This function can be compared to the conductor of an orchestra. It is the function that the compiler will begin and end its execution with. The main function is in charge of determining which other functions will be executed if any at all. Interestingly, it doesn’t have to be at the top of the class but it being at the top of the class might help with readability of your code. The main program has a specific signature or name i.e.\npublic static void main(String [] args)\n\n\n\n\n\n\nNote\n\n\n\nMemorize it because you will be writing it for every single Java program you write."
  },
  {
    "objectID": "lesson0_3.html",
    "href": "lesson0_3.html",
    "title": "0.3 Data structures",
    "section": "",
    "text": "A short introduction on Data structures\nYou don’t have to search for long to see different ways of organizing data in real life situations. Standing in line at the cafeteria, picking the winner in a March Madness bracket, writing down a shopping list, etc. All these examples allow us to use a certain resource in a manner that makes life somewhat easier. Computer Science, as a field, borrows a lot of these ideas in organizing data. The way that a programmer views and organizes the data that his/her program is using has bearing on the success/failure of multiple algorithms. Whereas the primitive types (int, float, double, long, char, byte, short, boolean) are adequate for simple programs, most programs you’ll be writing deal with large amounts of complicated and related data. In order to deal with such data, some structures have been used to represent this data and its relationships.\n\nSome data structures are based on how the programmer organizes the data i.e. how it is organized in memory. These structures are typically used as the basic building blocks of other structures. It is important to remember that with these structures, the implementation of the organization is what is important…more important than what kind of data is being organized, or when that data was encountered and/or organized.\n\nArrays are the most basic. Recall from the Living with Cyber classes, that arrays are used to store similar data in contiguous memory locations. They are available in almost all programming languages and data is accessed using its relative position (i.e. index)\nLinked Lists are also used to store elements in a sequence. However, the data is stored in nodes. Each node has one piece of data, as well as a link showing the location of the next node in the sequence. Think of a chain link.\n\n\nThese two basic structures are the building blocks of the other category of data structures i.e. those that are based on how the programmer views the data. Because these structures are based on how data is viewed (as opposed to how they are organized), sometimes these are called Abstract Data Types (remember “abstract” as a term refers to interpretation separate from concrete reality). These data structures are therefore independent of the implementation which is a concept that can be a little confusing the first time you hear about it.\n\nStacks are data structures that arrange data based on when that data was encountered. In this case, the last in is also the first out (LIFO). Compare this to a stack of plates at Tech Table. This way of looking at a data structure has nothing o do with how it is implemented. It could be an array or linked list (behind the scenes). As long as the data structure works in a LIFO manner, then it can be called a stack.\nQueues also arrange data based on when it was encountered but in a First In, First Out (FIFO) manner. Compare this to an orderly line to get your school identity card. Any piece of data removed from a queue is the piece of data that has been in the queue the longest.\nList is just a linear arrangement of data. It could be an array or linked list (behind the scenes) but as long as it supports the arrangement of data in a linear manner, it can be referred to as a list. Sometimes lists can also be sorted.\nMaps (a.k.a dictionaries, tables, associative arrays) are used to store key-value pairs. They allow the user quick access to a value when provided with the key. Compare it to your phone address book which hopefully provides you with a value (phone number, address, and message history) for every key (contact name) that you provide. Keys should be unique and each key should map to a single value.\nTrees are non-linear data structures. Data arranged in a tree stores both the value and some kind of relationship between those values. The restriction in trees is that each node is capable of having multiple successor nodes, but only one parent node. The parent of all nodes (without a parent itself) is called the root. Think about a tournament bracket.\nGraphs are also non-linear data structures but with less restrictions on the intra node relationships. Any node (typically called a vertex) can be connected (through an edge) to any other vertex. Sometimes even the edges have weights associated with them. Think road or airline routes.\n\n\n\nThere are some basic definitions we need to get out of the way before we dive into more complicated stuff.\nType: a collection of values. For example, a boolean type is collection of two values – true and false. A simple type (such as boolean or integer) will not have subparts, whereas an aggregate or composite type will contain several pieces of information.\nData item: a data item is a member of the type i.e. a piece of information derived from a type.\nData type: This is a combination of a type (the values) and the operations that can be applied to that type. For example, given the possible values of an integer (-231 – 231 -1), possible operations include addition, subtraction, division, etc.\nThere is a difference between the logical concept of a data type and its physical implementation (even if the line is blurred). Consider an array: Its logical concept is that of potentially homogeneous data items stored in a collection where each item is accessed using an index number. However, its physical implementation is a block of contiguous memory locations. The distinction between the two needs to be made because there are cases where arrays (particularly multi-dimensional arrays) have been designed with the same logical idea, but different physical implementation (i.e. the data items are not in contiguous memory locations) but that doesn’t make them any less of an array than a typical array. Another example is the list. Its logical concept is a collection of items, but its physical implementation could be either an array or a linked list. Both are lists, but they have very different physical implementations.\nAbstract data type: When the idea of a data type is realized as a software component i.e. the type and operations are realized in code. This is typically represented by an interface. It does NOT specify how the data type is implemented. In fact, such details are typically hidden from the user of the data type or any outside access.\nData structure: The complete implementation of an ADT. It typically takes the form of a class where the operations of the ADT are captured by member functions of that class.\nAn integer as well as the operations that an integer can be put through make up the integer data type. The java int variable is a physical representation of the abstract integer. This variable, alongside the java int operations make up an ADT. But there is difference between the two (i.e. a difference between a java int ADT and the abstract integer). The java int ADT can only support values within a certain range and we know that real integers do not have that limitation. If this limitation is a deal breaker for you, then you will have to figure out a different ADT (with different implementations) to represent your integers. \n \n    Ref:\nA Practical Introduction to Data Structures and Algorithm Analysis, Clifford A. Shaffer ; Object Oriented Data Structures using Java (4th Edition). Nell Dale, Daniel T. Joyce, Chip Weems."
  }
]