<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Java Preliminaries - Binary Trees</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body>

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul class="collapse">
  <li><a href="#what-exactly-is-a-binary-tree" id="toc-what-exactly-is-a-binary-tree" class="nav-link active" data-scroll-target="#what-exactly-is-a-binary-tree"><span class="header-section-number">1</span> What exactly is a binary tree?</a></li>
  <li><a href="#traversing-the-tree" id="toc-traversing-the-tree" class="nav-link" data-scroll-target="#traversing-the-tree"><span class="header-section-number">2</span> Traversing the tree</a></li>
  <li><a href="#binary-search-tree" id="toc-binary-search-tree" class="nav-link" data-scroll-target="#binary-search-tree"><span class="header-section-number">3</span> Binary Search Tree</a>
  <ul class="collapse">
  <li><a href="#insertion-into-a-binary-search-tree" id="toc-insertion-into-a-binary-search-tree" class="nav-link" data-scroll-target="#insertion-into-a-binary-search-tree"><span class="header-section-number">3.1</span> Insertion into a binary search tree</a></li>
  <li><a href="#finding-the-min-and-max" id="toc-finding-the-min-and-max" class="nav-link" data-scroll-target="#finding-the-min-and-max"><span class="header-section-number">3.2</span> Finding the min and max</a></li>
  <li><a href="#deleting-a-node" id="toc-deleting-a-node" class="nav-link" data-scroll-target="#deleting-a-node"><span class="header-section-number">3.3</span> Deleting a node</a></li>
  </ul></li>
  <li><a href="#wrap-up" id="toc-wrap-up" class="nav-link" data-scroll-target="#wrap-up"><span class="header-section-number">4</span> Wrap up</a>
  <ul class="collapse">
  <li><a href="#printing-trees" id="toc-printing-trees" class="nav-link" data-scroll-target="#printing-trees"><span class="header-section-number">4.1</span> Printing trees</a></li>
  <li><a href="#recreating-a-tree-from-its-inorder-and-preorder-traversals" id="toc-recreating-a-tree-from-its-inorder-and-preorder-traversals" class="nav-link" data-scroll-target="#recreating-a-tree-from-its-inorder-and-preorder-traversals"><span class="header-section-number">4.2</span> Recreating a tree from its inOrder and preOrder traversals</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Binary Trees</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<p>The highest priority when a programmer is organizing data is making sure that item insertions, deletion, and searches are fast. The first structure that we considered was an array. Insertion and deletion were quick but searches were not. This weakness becomes even more pronounced with larger data sizes.</p>
<p>The next idea was to sort the array i.e.&nbsp;an ordered array. That way we could employ binary searches which made the searching way faster. However, Insertions and deletions became slower as a result. This is because we would have to expand and collapse the list respectively, both of which required data movement, and that is an expensive step particularly for larger data sizes.</p>
<p>To speed up insertions and deletions, we turned to linked lists. Insertion and deletion in a linked list did not require any major data movement; we simply adjusted a few nodes in the list. However, the draw back for linked lists is that they must be processed sequentially i.e.&nbsp;we had to traverse from the head in their proper order to find or process any node. So even though the insertion and deletion didn’t require much data movement, we had to begin our searches at the first node in the list every time.</p>
<p>The next data structure that we will discuss is the binary tree which attempts to combine the best features of arrays and linked lists i.e.&nbsp;it allows quick searching (like in an ordered array), but also allow fast insertion and deletion (like a linked list)</p>
<section id="what-exactly-is-a-binary-tree" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> What exactly is a binary tree?</h1>
<p>A binary tree is a data structure made up of nodes (kinda like linked lists) connected by <strong>edges</strong>. Nodes typically contain “entities” or complex objects, and the edges represent node inter-relatedness.</p>
<p>A binary tree T is either empty or has the following properties</p>
<ul>
<li>Has a special node called the root node.</li>
<li>Has two (hence the binary) sets of nodes <span class="math inline">\(L_T\)</span> and <span class="math inline">\(R_T\)</span> called the <strong>left subtree</strong> and <strong>right subtree</strong> respectively.</li>
<li><span class="math inline">\(L_T\)</span> and <span class="math inline">\(R_T\)</span> are binary trees.</li>
</ul>
<p>Binary trees can be represented diagrammatically as shown in the figure below. Nodes are represented as circles, and labeled by the node. The root node is drawnat the top (yes the root is at the top). The root of the left subtree is called a <strong>left child</strong>, and the root of the right subtree is called the <strong>right child</strong>. The child nodes are drawn below and to the left or right of the their <strong>parent node</strong>. The edges have a direction i.e.&nbsp;from the parent to the child. The edges can also be referred to as <strong>directed edges, branches</strong> or <strong>directed branches</strong>.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/6 (1).svg" class="img-fluid figure-img" width="300"></p>
</figure>
</div>
<p>In the diagram above, A is the root node. Its left subtree is denoted by <span class="math inline">\(L_A\)</span> and its right subtree by <span class="math inline">\(R_A\)</span>. The root of <span class="math inline">\(L_A\)</span> is B and the root of <span class="math inline">\(R_A\)</span> is C. <span class="math inline">\(L_A\)</span> and <span class="math inline">\(R_A\)</span> are also binary trees themselves. C has no left child, and G has no children at all. Also recall that since it is a binary tree, each node has a maximum of two children. Any node that does not have ANY children is called a <strong>leaf node</strong>. Therefore E, G, and Hare the leaves of the binary tree above.</p>
<p>A <strong>path</strong> from a node to another node is a sequence of nodes that one has to go through to move from any given node to a node in one of its subtrees. For example, the path from A to G is A, B, D, G. You might have noticed that there is a unique path from the root node to every node in the binary tree.</p>
<p>The <strong>length</strong> of a path in a binary tree is the number of branches or edges in that path. For example, the path from A to G has a length of 3.</p>
<p>The <strong>level</strong> of a node in a binary tree is the number of branches on the path from the root to that node. For example, node F is at level 2. Notice that the levels count downwards.</p>
<p>The <strong>height</strong> of a tree is the number of nodes on the longest path from the root to a leaf. In the diagram above, the height of the tree is 4. Notice that for length and level we count edges, but for height, we count nodes.</p>
<p>From the description thus far, it stands to reason that the implementation of a node of a binary tree is very similar to the node of a linked list. However, instead of just keeping track of the link to the next node, it must keep track of both its leftand right children.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode java code-with-copy"><code class="sourceCode java"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="bu">TreeNode</span> <span class="co">// missing accessors, mutators, constructor, etc.</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="dt">int</span> data<span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="bu">TreeNode</span> left<span class="op">;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="bu">TreeNode</span> right<span class="op">;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The data is stored in the member called <em>data</em>. The left subtree is pointed to by <em>left</em>, and the right subtree is pointed to by <em>right</em>.</p>
<p>We can have a reference to the first <em>TreeNode</em> that we can call <em>root</em> to keep track of the root of the tree.</p>
</section>
<section id="traversing-the-tree" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Traversing the tree</h1>
<p>Insertion, deletion and searching all require that the binary tree is traversed, which means that traversing (or visiting) the tree is the most common operation performed on it. It makes sense to start the traversal at the root since we have a pointer to it.</p>
<p>For each node, we have two choices</p>
<ul>
<li>visit that node first (which could include any processing of its data e.g.&nbsp;printing, counting, etc.)</li>
<li>visit the subtrees first.</li>
</ul>
<p>The order in which these are done lead to three commonly used traversals of a binary tree.</p>
<ul>
<li>Inorder traversal ( traverse left subtree, visit the node, then traverse right subtree) a.k.a. LNR</li>
<li>Preorder traversal (visit the node, traverse the left subtree, and then the right subtree) a.k.a. NLR.</li>
<li>Postorder traversal (traverse the left subtree, then the right subtree, and then visit the node) a.k.a. LRN.</li>
</ul>
<p>It should be easy to see that these traversal algorithms are recursive. (remember recursion from Chapter 12) Lets look at an easy example of an inorder traversal to print out the data in each node.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode java code-with-copy"><code class="sourceCode java"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">InOrder</span><span class="op">(</span><span class="bu">TreeNode</span> n<span class="op">)</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">!=</span> <span class="kw">null</span><span class="op">)</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>        <span class="fu">InOrder</span><span class="op">(</span>n<span class="op">.</span><span class="fu">getLeft</span><span class="op">());</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">print</span><span class="op">(</span>n<span class="op">.</span><span class="fu">getData</span><span class="op">()</span> <span class="op">+</span> “ “<span class="op">);</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>        <span class="fu">InOrder</span><span class="op">(</span>n<span class="op">.</span><span class="fu">getRight</span><span class="op">());</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="callout callout-style-default callout-important no-icon callout-titled" title="Activity">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-1-contents" aria-controls="callout-1" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Activity
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-1" class="callout-1-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Let’s see if you can come up with the PreOrder and PostOrder traversal algorithms. Given how the InOrder looks above, coming up with the remaining two traversals should be trivial.</p>
</div>
</div>
</div>
<div class="callout callout-style-default callout-important no-icon callout-titled" title="Activity">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-2-contents" aria-controls="callout-2" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Activity
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-2" class="callout-2-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>What would the inorder, preorder, and postorder traversals for the tree in the diagram on page 2 look like?</p>
</div>
</div>
</div>
</section>
<section id="binary-search-tree" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Binary Search Tree</h1>
<p>We’ve said that traversing the tree could potentially take a long time. The reason for this is that no criteria exists to guide our search. If we were looking for Node 54 in the tree on the left (below), we would have to traverse the entire tree before ascertaining that that node didn’t exist. This kinda defeats our purpose of having the binary tree in the first place i.e.&nbsp;making insertion, deletion and searching quick.</p>
<div class="quarto-layout-panel">
<div class="quarto-layout-row quarto-layout-valign-top">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: center;">
<p><img src="images/6 (2).svg" class="img-fluid" width="300"></p>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: center;">
<p><img src="images/6 (3).svg" class="img-fluid" width="300"></p>
</div>
</div>
</div>
<p>However, there is a special way of arranging an arbitrary tree that makes searching way faster. Its called a binary search tree and an example is in the diagram to the right above. It has the exact same properties as a binary search tree as we discussed before but it has an extra property.</p>
<ul>
<li>The key in the root node is larger than every key in the left subtree, and smaller than every key in the right subtree.</li>
</ul>
<p>This extra property means that if we are looking for a node in our tree, we can effectively reduce our search space by half depending on a comparison between aroot node and the key of the node we are looking for. A natural consequence of this rule is that a binary search tree does not typically allow duplicate values. There are ways to go round this but they are beyond the scope of this class.</p>
<p>For example, if we are searching for 77 in the binary search tree (which is on the right), we compare 77 and 60. Since 77 is greater than 60, we ignore the left subtree and only consider the right subtree. We then compare 77 with 70 (which is the root of the right subtree…and is also a binary search tree in an of itself), and discard the left subtree of that node. 77 is less than 80 so we have to look at its left subtree, and we find 77.</p>
<p>What about if we were looking for a number that wasn’t in the tree? Let’s say we were looking for 59. Well 59 is less than 60 so we go to the left subtree. 59 is greater than 50 so we go to its right subtree. 59 is greater than 58 but we can’t go to its right subtree because that tree is <em>null</em>.Therefore, 59 is not in the tree.</p>
<p>Remember complexity and big-O? What is the complexity of an algorithm that effectively halves its search space with each step? <span class="math inline">\(O(log_2n)\)</span>. This is significantly better than <span class="math inline">\(O(n)\)</span> which was the complexity of searching through a linked list.</p>
<section id="insertion-into-a-binary-search-tree" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="insertion-into-a-binary-search-tree"><span class="header-section-number">3.1</span> Insertion into a binary search tree</h2>
<p>You might have realized that the order of the nodes is important in a binary search tree. Well how do we insert a node into the tree while maintaining all the rules that make it very efficient?</p>
<p>Nodes are ALWAYS inserted as leaves. Remember a leaf is a node that doesn’t have any children. First we search the tree to find the appropriate position for our new leaf node. Compare with the root, and go to the left or right subtree based onthat comparison. Keep on repeating that step until the subtree is NULL. At this point, insert the node and make sure that the node you were in is pointing to the new node using the appropriate link.</p>
<p>For example, suppose I wanted to add a 55 to the binary search tree we saw earlier. 55 is less than 60 so we go to the left subtree of the root. It’s greater than 50 so we go to the right subtree of that node. Its less than 58 but there is no left subtree so we add the new node in that position.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/6 (4).svg" class="img-fluid figure-img" width="300"></p>
</figure>
</div>
<div class="callout callout-style-default callout-important no-icon callout-titled" title="Activity">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-3-contents" aria-controls="callout-3" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Activity
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-3" class="callout-3-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Try and insert the following nodes to the tree above. <code>65, 68, 79</code></p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/6 (5).svg" class="img-fluid figure-img" width="300"></p>
</figure>
</div>
</div>
</div>
</div>
<div class="sourceCode" id="cb3"><pre class="sourceCode java code-with-copy"><code class="sourceCode java"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">/* </span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="co"> this function inserts the integer x into the tree in the appropriate position </span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="co">*/</span> </span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="bu">TreeNode</span> <span class="fu">insert</span><span class="op">(</span><span class="dt">int</span> x<span class="op">,</span> <span class="bu">TreeNode</span> root<span class="op">)</span> </span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="op">{</span> </span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">TreeNode</span> current<span class="op">,</span> trail<span class="op">,</span> newnode<span class="op">;</span> <span class="co">//pointers to the current node, the node before </span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">//the current (called trail), and a pointer to the </span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">//new node that we will create from int x. </span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    newnode <span class="op">=</span> <span class="kw">new</span> <span class="bu">TreeNode</span><span class="op">();</span> <span class="co">//create the new node and initialize it appropriately </span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    newnode<span class="op">.</span><span class="fu">setData</span><span class="op">(</span>x<span class="op">);</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    newnode<span class="op">.</span><span class="fu">setLeft</span><span class="op">(</span><span class="kw">null</span><span class="op">);</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    newnode<span class="op">.</span><span class="fu">setRight</span><span class="op">(</span><span class="kw">null</span><span class="op">);</span> </span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>root <span class="op">==</span> <span class="kw">null</span><span class="op">)</span> <span class="co">//if the root is null (i.e. no tree yet), </span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>        root <span class="op">=</span> newnode<span class="op">;</span> <span class="co">//just set the root to the newnode </span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> </span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span> </span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>        current <span class="op">=</span> root<span class="op">;</span> </span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="op">(</span>current <span class="op">!=</span> <span class="kw">null</span><span class="op">)</span> <span class="co">//this while loop will set trail to the current node and</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span>           <span class="co">//then move "current" to the appropriate subtree until</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>                    <span class="co">//both current and trail are at the bottom of the tree </span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>            trail <span class="op">=</span> current<span class="op">;</span> </span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>current<span class="op">.</span><span class="fu">getData</span><span class="op">()</span> <span class="op">==</span> x<span class="op">)</span>         <span class="co">//we don't want duplicate values in our tree </span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>            <span class="op">{</span> </span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>                <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span>“we don’t want duplicate values”<span class="op">);</span></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span><span class="op">;</span> </span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> </span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>current<span class="op">.</span><span class="fu">getData</span><span class="op">()</span> <span class="op">&gt;</span> x<span class="op">)</span>      <span class="co">//if x is less, move current to the left subtree </span></span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>                current <span class="op">=</span> current<span class="op">.</span><span class="fu">getLeft</span><span class="op">();</span> </span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span> <span class="co">//otherwise, move current to the right subtree </span></span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a>                current <span class="op">=</span> current<span class="op">.</span><span class="fu">getRight</span><span class="op">();</span> </span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a>    <span class="co">//right now trail points to the last node before our insertion, and current is null. </span></span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>trail<span class="op">.</span><span class="fu">getData</span><span class="op">()</span> <span class="op">&gt;</span> x<span class="op">)</span> </span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true" tabindex="-1"></a>        trail<span class="op">.</span><span class="fu">setLeft</span><span class="op">(</span>newnode<span class="op">);</span> </span>
<span id="cb3-39"><a href="#cb3-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> </span>
<span id="cb3-40"><a href="#cb3-40" aria-hidden="true" tabindex="-1"></a>        trail<span class="op">.</span><span class="fu">setRight</span><span class="op">(</span>newnode<span class="op">);</span> </span>
<span id="cb3-41"><a href="#cb3-41" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> </span>
<span id="cb3-42"><a href="#cb3-42" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> root<span class="op">;</span></span>
<span id="cb3-43"><a href="#cb3-43" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="finding-the-min-and-max" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="finding-the-min-and-max"><span class="header-section-number">3.2</span> Finding the min and max</h2>
<p>With a binary search tree, finding the minimum value is just a matter of following the left edges until the left most node. This node is the minimum.</p>
<p>Finding the maximum is the opposite: follow the right edges until the right most node.</p>
</section>
<section id="deleting-a-node" class="level2" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="deleting-a-node"><span class="header-section-number">3.3</span> Deleting a node</h2>
<p>We’ve inserted, we’ve searched…last thing to do is delete. Deleting also requires searching for the appropriate node. Good thing we can now do that in <span class="math inline">\(O(log_2n)\)</span>.</p>
<p>The delete operation shouldn’t change the tree from a binary search tree and this restriction brings up some different cases.</p>
<p><strong>Case 1: The node to be deleted is a leaf</strong> This is the most straightforward case. To delete the leaf, we modify the parent’s link to this node and make it NULL.</p>
<p>For example, if we wanted to delete 30 from the tree below on the left, we would just change 50’s left link to NULL.</p>
<div class="quarto-layout-panel">
<div class="quarto-layout-row quarto-layout-valign-top">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: center;">
<p><img src="images/6 (6).svg" class="img-fluid" width="300"></p>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: center;">
<p><img src="images/6 (7).svg" class="img-fluid" width="300"></p>
</div>
</div>
</div>
<p><strong>Case 2: The node to be deleted has one child</strong> This case is also fairly straightforward. We simply promote that child to take the position of the parent. This involves making the “grandparent” point directly to the child node. For example, if we wanted to delete 50 from the tree above, we would just promote 58 to level 1 i.e.&nbsp;make it directly connected to 60.</p>
<div class="quarto-layout-panel">
<div class="quarto-layout-row quarto-layout-valign-top">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: center;">
<p><img src="images/6 (8).svg" class="img-fluid" width="300"></p>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: center;">
<p><img src="images/6 (9).svg" class="img-fluid" width="300"></p>
</div>
</div>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/6 (10).svg" class="img-fluid figure-img" width="300"></p>
</figure>
</div>
<p><strong>Case 3: The node to be deleted has two children.</strong> In this case, we find the node’s successor and swap it with the deleted node. The node’s successor is the next highest node in the binary search tree. To identify it, traverse the right edge, and then traverse left edges until you find a leaf node. For example, if I wanted to delete 60 from the tree above, I would find 60’s successor by traversing the right edge (to 70) and then left edges till I couldn’t find any other left edge (65), and then move 65 to the position that 60 originally held.</p>
<div class="quarto-layout-panel">
<div class="quarto-layout-row quarto-layout-valign-top">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: center;">
<p><img src="images/6 (11).svg" class="img-fluid" width="300"></p>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: center;">
<p><img src="images/6 (12).svg" class="img-fluid" width="300"></p>
</div>
</div>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/6 (13).svg" class="img-fluid figure-img" width="300"></p>
</figure>
</div>
<p>What if it was a more complicated tree?</p>
<div class="quarto-layout-panel">
<div class="quarto-layout-row quarto-layout-valign-top">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: center;">
<p><img src="images/6 (15).svg" class="img-fluid" width="300"></p>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: center;">
<p><img src="images/6 (16).svg" class="img-fluid" width="300"></p>
</div>
</div>
</div>
<div class="quarto-layout-panel">
<div class="quarto-layout-row quarto-layout-valign-top">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: center;">
<p><img src="images/6 (17).svg" class="img-fluid" width="300"></p>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: center;">
<p><img src="images/6 (18).svg" class="img-fluid" width="300"></p>
</div>
</div>
</div>
</section>
</section>
<section id="wrap-up" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> Wrap up</h1>
<section id="printing-trees" class="level2" data-number="4.1">
<h2 data-number="4.1" class="anchored" data-anchor-id="printing-trees"><span class="header-section-number">4.1</span> Printing trees</h2>
<p>Recursion provides a pretty nifty way of printing trees. They can be printed from right to left using the function below. In it, the variable lev refers to the number of tabs.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode java code-with-copy"><code class="sourceCode java"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> <span class="fu">print</span><span class="op">(</span><span class="bu">TreeNode</span> n<span class="op">,</span> <span class="dt">int</span> lev<span class="op">)</span> </span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span> </span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">!=</span> <span class="kw">null</span><span class="op">)</span> </span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span> </span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>        <span class="fu">print</span><span class="op">(</span>n<span class="op">.</span><span class="fu">getRight</span><span class="op">(),</span> lev<span class="op">+</span><span class="dv">1</span><span class="op">);</span>     <span class="co">//go down the right subtree and increase </span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>                                        <span class="co">//the number of tabs i'll have to make</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> lev<span class="op">;</span> i<span class="op">++)</span> </span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>            <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">print</span><span class="op">(</span><span class="st">"</span><span class="sc">\t</span><span class="st">"</span><span class="op">);</span>     <span class="co">//print out the appropriate no. of tabs</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span>n<span class="op">.</span><span class="fu">getData</span><span class="op">());</span><span class="co">//and the data, and move to next line</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>        <span class="fu">print</span><span class="op">(</span>n<span class="op">.</span><span class="fu">getLeft</span><span class="op">(),</span> lev<span class="op">+</span><span class="dv">1</span><span class="op">);</span>      <span class="co">//go down the left subtree and increase </span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>                                        <span class="co">//tabs</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> </span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="recreating-a-tree-from-its-inorder-and-preorder-traversals" class="level2" data-number="4.2">
<h2 data-number="4.2" class="anchored" data-anchor-id="recreating-a-tree-from-its-inorder-and-preorder-traversals"><span class="header-section-number">4.2</span> Recreating a tree from its inOrder and preOrder traversals</h2>
<p>The diagramatic representation of a tree can be recreated from its in order and preorder traversals.</p>
<p>Remember that inorder is LNR i.e.&nbsp;visit the left subtree, then the node, then the right, whereas preorder is NLR i.e.&nbsp;visit the node first, then the left subtree and end with the right subtree.</p>
<p>For example consider the two sequences below.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode java code-with-copy"><code class="sourceCode java"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>Inorder<span class="op">:</span>  B C E F G H J K P R S X Z</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>preorder<span class="op">:</span> J E B C G F H P K S R X Z</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Preorder starts with the node so we know that J must be the root node. However, Inorder visits the left subtree before getting to the root so we can say that all the letters to the left of J must be in its left subtree i.e.&nbsp;B C E F G and H. Conversely, the right subtree of the root J consists of K P R S X and Z.</p>
<p>Preorder says our next node (after the root J) is E. From in order, we see that the left subtree of E is B and C, while its right subtree is F, G, and H.</p>
<p>Preorder dictates that our next node after E is B. The left subtree of B (acc. to the inorder) has nothing, but its right subtree has C (Recall that C is also in the left subtree of E which means that it is to the right of B but left of E).</p>
<p>I leave it up to you to follow through with all the nodes until you get to the tree shown below.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/6 (19).svg" class="img-fluid figure-img" width="300"></p>
</figure>
</div>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>